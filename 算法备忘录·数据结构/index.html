<!DOCTYPE html><html lang=zh-CN data-default-color-scheme=auto><head><meta charset=UTF-8><link rel=apple-touch-icon sizes=76x76 href=/img/favicon/favicon.png><link rel=icon href=/img/favicon/favicon.png><link rel=canonical href=https://justloseit.top/算法备忘录·数据结构/ ><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=theme-color content=#2f4154><meta name=author content="Mobilis In Mobili"><meta name=keywords content=""><meta name=description content="一直以来，没能系统学习算法，是我心中的痛；现在学了 y 总的算法基础课，做做笔记，希望能够有所收获。 这是第二节，数据结构。"><meta property=og:type content=article><meta property=og:title content=算法备忘录·数据结构><meta property=og:url content=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html><meta property=og:site_name content=动中之动><meta property=og:description content="一直以来，没能系统学习算法，是我心中的痛；现在学了 y 总的算法基础课，做做笔记，希望能够有所收获。 这是第二节，数据结构。"><meta property=og:locale content=zh_CN><meta property=og:image content=https://justloseit.top/img/index/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg><meta property=article:published_time content=2021-08-07T12:46:25.000Z><meta property=article:modified_time content=2024-05-14T17:36:43.145Z><meta property=article:author content="Mobilis In Mobili"><meta property=article:tag content=计算机><meta property=article:tag content=算法><meta name=twitter:card content=summary_large_image><meta name=twitter:image content=https://justloseit.top/img/index/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg><title>算法备忘录·数据结构 - 动中之动</title><link rel=stylesheet href=https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css><link rel=stylesheet href=https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css><link rel=stylesheet href=https://lib.baomitu.com/hint.css/2.7.0/hint.min.css><link rel=stylesheet href=https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css><link rel=stylesheet href=https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css><link rel=stylesheet href=//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css><link rel=stylesheet href=//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css><link rel=stylesheet href=/css/main.css><link id=highlight-css rel=stylesheet href=/css/highlight.css><link id=highlight-css-dark rel=stylesheet href=/css/highlight-dark.css><script id=fluid-configs>var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"justloseit.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:60,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"snI2XNrHrhyx5g84m3Uim3EC-gzGzoHsz",app_key:"x2YseXJIHmvnsM4v9y9UAlvu",server_url:"https://sni2xnrh.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src=/js/utils.js></script><script src=/js/color-schema.js></script><meta name=generator content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="动中之动" type="application/atom+xml">
</head><body><header><div class=header-inner style=height:70vh><nav id=navbar class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class=container><a class=navbar-brand href=/ ><strong>Mobilis In Mobili</strong> </a><button id=navbar-toggler-btn class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation"><div class=animated-icon><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav ml-auto text-center"><li class=nav-item><a class=nav-link href=/ target=_self><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class=nav-item><a class=nav-link href=/archives/ target=_self><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class=nav-item><a class=nav-link href=/categories/ target=_self><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class=nav-item><a class=nav-link href=/tags/ target=_self><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class=nav-item><a class=nav-link href=/about/ target=_self><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class=nav-item><a class=nav-link href=/links/ target=_self><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class=nav-item id=search-btn><a class=nav-link target=_self href=javascript:; data-toggle=modal data-target=#modalSearch aria-label=Search><i class="iconfont icon-search"></i></a></li><li class=nav-item id=color-toggle-btn><a class=nav-link target=_self href=javascript:; aria-label="Color Toggle"><i class="iconfont icon-dark" id=color-toggle-icon></i></a></li></ul></div></div></nav><div id=banner class=banner parallax=true style="background:url(/img/banner/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg) no-repeat center center;background-size:cover"><div class=full-bg-img><div class="mask flex-center" style=background-color:rgba(0,0,0,.3)><div class="banner-text text-center fade-in-up"><div class=h2><span id=subtitle data-typed-text=算法备忘录·数据结构></span></div><div class=mt-3><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden=true></i> Mobilis In Mobili </span><span class=post-meta><i class="iconfont icon-date-fill" aria-hidden=true></i> <time datetime="2021-08-07 20:46" pubdate>2021年8月7日 晚上</time></span></div><div class=mt-1><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 25 分钟 </span><span id=leancloud-page-views-container class=post-meta style=display:none><i class="iconfont icon-eye" aria-hidden=true></i> <span id=leancloud-page-views></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id=board-ctn><div id=board><article class="post-content mx-auto"><h1 id=seo-header>算法备忘录·数据结构</h1><p id=updated-time class="note note-info">本文最后更新于 2024年5月15日 凌晨</p><div class=markdown-body><p>一直以来，没能系统学习算法，是我心中的痛；现在学了 y 总的算法基础课，做做笔记，希望能够有所收获。<br>这是第二节，数据结构。</p><span id=more></span><h1 id=数据结构><a class=markdownIt-Anchor href=#数据结构></a> 数据结构</h1><h2 id=链表><a class=markdownIt-Anchor href=#链表></a> 链表</h2><ul><li>通常情况，动态链表的速度较慢。这往往难以满足算法题的要求，因此使用数组来静态的表示链表。</li></ul><h3 id=单链表><a class=markdownIt-Anchor href=#单链表></a> 单链表</h3><ul><li><p>模板</p><ul><li><code>head</code> 储存链表头（直接记录了第一个节点的<strong>位置</strong>），<code>e[]</code> 存储节点的值，<code>ne[]</code> 存储节点指向的下一个节点<strong>位置</strong>，<code>idx</code> 表示当前用到哪个节点</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-comment>// 初始化</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>init</span><span class=hljs-params>()</span></span>&#123;<br>    head = <span class=hljs-number>-1</span>; <span class=hljs-comment>// -1 表示指向空集</span><br>    idx = <span class=hljs-number>0</span>;<br>&#125;<br><br><span class=hljs-comment>//  在链表头插入一个数 a，注意是先新节点指向下一个，再表头指向新节点</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>insert</span><span class=hljs-params>(<span class=hljs-type>int</span> a)</span></span>&#123;<br>    e[idx] = a, ne[idx] = head, head = idx, idx ++;<br>&#125;<br><br><span class=hljs-comment>// 删除头节点，需要保证头节点存在</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>remove</span><span class=hljs-params>()</span></span>&#123;<br>    head = ne[head];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id=双链表><a class=markdownIt-Anchor href=#双链表></a> 双链表</h3><ul><li><p>模板</p><ul><li><code>e[]</code> 存储节点的值，<code>l[]</code> 存储节点指向的上一个节点<strong>位置</strong>，<code>r[]</code> 存储节点指向的下一个节点<strong>位置</strong>，<code>idx</code> 表示当前用到哪个节点。设 <strong>0 是左端点， 1 是右端点</strong>，因此 <strong><code>idx</code> 从 2 开始</strong>。</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-comment>// 初始化</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>init</span><span class=hljs-params>()</span></span>&#123;<br>    r[<span class=hljs-number>0</span>] = <span class=hljs-number>1</span>, l[<span class=hljs-number>1</span>] = <span class=hljs-number>0</span>;<br>    idx = <span class=hljs-number>2</span>;<br>&#125;<br><br><span class=hljs-comment>//  在节点 a 的右边插入数 x</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>insert</span><span class=hljs-params>(<span class=hljs-type>int</span> a, <span class=hljs-type>int</span> x)</span></span>&#123;<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx;<br>    idx ++;<br>&#125;<br><br><span class=hljs-comment>// 删除节点 a</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>remove</span><span class=hljs-params>(<span class=hljs-type>int</span> a)</span></span>&#123;<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id=栈-队列><a class=markdownIt-Anchor href=#栈-队列></a> 栈、队列</h2><h3 id=栈><a class=markdownIt-Anchor href=#栈></a> 栈</h3><ul><li><p>FILO</p></li><li><p>模板</p><ul><li>设<strong>栈顶初始为 0，表示空</strong>， <code>tt</code> 总指向<strong>栈顶元素</strong></li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-comment>// tt 表示栈顶</span><br><span class=hljs-type>int</span> stk[tt], tt = <span class=hljs-number>0</span>;<br><br><span class=hljs-comment>// 向栈顶插入一个数</span><br>stk[++ tt] = x;<br><br><span class=hljs-comment>// 栈顶弹出一个数</span><br>tt --;<br><br><span class=hljs-comment>// 栈顶的值</span><br>stk[tt];<br><br><span class=hljs-comment>// 判断栈是否为空</span><br><span class=hljs-keyword>if</span> (tt &gt; <span class=hljs-number>0</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id=队列><a class=markdownIt-Anchor href=#队列></a> 队列</h3><ul><li>FIFO</li></ul><h4 id=普通队列><a class=markdownIt-Anchor href=#普通队列></a> 普通队列</h4><ul><li><p>模板</p><ul><li>设<strong>队头初始为 1，队尾初始为 -1，表示空</strong>，<code>tt</code> 总指向<strong>队尾元素</strong></li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> q[N], hh = <span class=hljs-number>0</span>, tt = <span class=hljs-number>-1</span>;<br><br><span class=hljs-comment>// 向队尾插入一个数</span><br>q[++ tt] = x;<br><br><span class=hljs-comment>// 从队头弹出一个数</span><br>hh ++；<br><br><span class=hljs-comment>// 队头的值</span><br>q[tt];<br><br><span class=hljs-comment>// 判断队列是否为空</span><br><span class=hljs-keyword>if</span> (hh &lt;= tt)&#123;<br><br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h4 id=循环队列><a class=markdownIt-Anchor href=#循环队列></a> 循环队列</h4><ul><li><p>模板</p><ul><li>设<strong>队头初始为 0，队尾初始为 0，表示空</strong>，<code>tt</code> 总指向<strong>队尾元素的后一个位置</strong>——因为如果按照普通队列那样初始化，队尾就到了 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding=application/x-tex>N-1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.76666em;vertical-align:-.08333em></span><span class="mord mathdefault" style=margin-right:.10903em>N</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>1</span></span></span></span> 处</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> q[N], hh = <span class=hljs-number>0</span>, tt = <span class=hljs-number>0</span>;<br><br><span class=hljs-comment>// 向队尾插入一个数</span><br>q[tt ++] = x;<br><span class=hljs-keyword>if</span> (tt == N) tt = <span class=hljs-number>0</span>;<br><br><span class=hljs-comment>// 从队头弹出一个数</span><br>hh ++;<br><span class=hljs-keyword>if</span> (hh == N) hh = <span class=hljs-number>0</span>;<br><br><span class=hljs-comment>//队头的值</span><br>q[hh];<br><br><span class=hljs-comment>//判断队列是否为空</span><br><span class=hljs-keyword>if</span> (hh != tt)&#123;<br><br>&#125; <br></code></pre></td></tr></table></figure></li></ul><h3 id=单调栈><a class=markdownIt-Anchor href=#单调栈></a> 单调栈</h3><ul><li><p>满足<strong>单调性</strong>的栈结构，<strong>插入</strong>时要维护其单调性</p></li><li><p>常见模型：找出每个数这边<strong>离它最近的比它大/小的数</strong></p></li><li><p>模板（插入）</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> tt = <span class=hljs-number>0</span>;<br><span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>0</span>; i &lt; n; i ++)&#123;<br>    <span class=hljs-keyword>while</span> (tt &amp;&amp; <span class=hljs-built_in>check</span>(stk[tt],i)) tt --;<br>    stk[++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id=单调队列><a class=markdownIt-Anchor href=#单调队列></a> 单调队列</h3><ul><li><p>满足<strong>单调性</strong>的队列结构，<strong>队尾插入</strong>要维护其单调性</p></li><li><p>常见模型：找出<strong>滑动窗口</strong>中的最大值/最小值</p></li><li><p>模版（插入）</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> hh = <span class=hljs-number>0</span>, tt = <span class=hljs-number>-1</span>;<br><span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>0</span>; i &lt; n; i ++)&#123;<br>    <span class=hljs-keyword>while</span> (hh &lt;= tt &amp;&amp; <span class=hljs-built_in>check_out</span>(q[hh])) hh ++; <span class=hljs-comment>// 判断队头是否在滑动窗口中</span><br>    <span class=hljs-keyword>while</span> (hh &lt;= tt &amp;&amp; <span class=hljs-built_in>check</span>(q[tt], i)) tt--; <span class=hljs-comment>// 这里和单调栈一样</span><br>    q[++ tt] = i;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id=kmp><a class=markdownIt-Anchor href=#kmp></a> KMP</h2><ul><li><p>问题：模板串 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=application/x-tex>p</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.625em;vertical-align:-.19444em></span><span class="mord mathdefault">p</span></span></span></span> 在 模式串 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=application/x-tex>s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">s</span></span></span></span> 中 的匹配</p></li><li><p>KMP 算法的思路</p><ul><li>每次<strong>失配</strong>时，不是像暴力那样把模板串 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=application/x-tex>p</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.625em;vertical-align:-.19444em></span><span class="mord mathdefault">p</span></span></span></span> 往后<strong>移动一位</strong>，而是把 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=application/x-tex>p</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.625em;vertical-align:-.19444em></span><span class="mord mathdefault">p</span></span></span></span> 串向后<strong>移动多位</strong>。这里的移动位数对应的是找到<strong>长度最长的相等前缀串</strong>，所以可以一次移动多位了。</li><li>对于每个模板串的字符，如果失配时，应该具体移动多少位呢？定义 <code>next[]</code> 数组来存模式串中每个前缀最长能够匹配前缀字符串的字符的下标。——我们发现相等前缀串是和模式串<strong>无关的</strong></li></ul></li><li><p>如何求 <code>next[]</code> ？</p><ul><li>首先看 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=application/x-tex>p</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.625em;vertical-align:-.19444em></span><span class="mord mathdefault">p</span></span></span></span> 在 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=application/x-tex>s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">s</span></span></span></span> 中是如何匹配的。设 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=application/x-tex>p</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.625em;vertical-align:-.19444em></span><span class="mord mathdefault">p</span></span></span></span> 和 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=application/x-tex>s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">s</span></span></span></span> 的<strong>起始下标均为 1</strong>，<code>j</code> 指向 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>p</mi></mrow><annotation encoding=application/x-tex>p</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.625em;vertical-align:-.19444em></span><span class="mord mathdefault">p</span></span></span></span> <strong>已经在 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>s</mi></mrow><annotation encoding=application/x-tex>s</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">s</span></span></span></span> 中匹配的部分</strong>（因此，初始 <code>j = 0</code>）。如果<code>j+1</code>位无法匹配，那么就移动位数，使 <code>j = ne[j]</code>。继续以上操作，如果能够匹配就比较下一位，相应的<code>j ++</code>。<ul><li>由于初始下标为 1，用 <code>string</code> 类型输入是不行的。可以开两个<code>char[]</code>，然后 <code>cin &gt;&gt; p + 1 &gt;&gt; s + 1</code>。</li></ul></li><li>接下来，考虑求 <code>next[]</code>。事实上两个串之间匹配是<strong>相互的</strong>，因为模板串移动匹配模式串也可以看成模式串移动匹配模板串。所以，我们求 <code>ne[i]</code> 时，相当于每次用模板串匹配模板串的<code>[1,i]</code>位。我们选择初始化 <code>i = 2</code>，是因为 <code>ne[1]=0</code> 始终成立。</li></ul></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-comment>// s[] 为模式串，p[] 为模板串</span><br><br><span class=hljs-comment>// 首先求 next[]</span><br><span class=hljs-keyword>for</span>(<span class=hljs-type>int</span> i = <span class=hljs-number>2</span>, j = <span class=hljs-number>0</span>; i &lt;= p.<span class=hljs-built_in>size</span>(); i ++)&#123;<br>    <span class=hljs-keyword>while</span> (j &amp;&amp; p[i] != p[j + <span class=hljs-number>1</span>]) j = ne[j];<br>    <span class=hljs-keyword>if</span> (p[i] == p[j + <span class=hljs-number>1</span>]) j ++;<br>    ne[i] = j;<br>&#125;<br><br><span class=hljs-comment>// 匹配</span><br><span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>, j = <span class=hljs-number>0</span>; i &lt;= s.<span class=hljs-built_in>size</span>(); i ++)&#123;<br>    <span class=hljs-keyword>while</span> (j &amp;&amp; s[i] != p[j + <span class=hljs-number>1</span>]) j = ne[j];<br>    <span class=hljs-keyword>if</span> (s[i] == p[j + <span class=hljs-number>1</span>]) j ++;<br>    <span class=hljs-keyword>if</span> (j == p.<span class=hljs-built_in>size</span>())&#123;<br>      j = ne[j]; <span class=hljs-comment>// 继续寻找下一个</span><br>      <span class=hljs-comment>//  匹配成功后的逻辑</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h2 id=trie-树><a class=markdownIt-Anchor href=#trie-树></a> Trie 树</h2><ul><li><p>用途：高效<strong>存取</strong>和<strong>查找</strong>字符串集合</p></li><li><p>思路：每个节点存储一位字符</p></li><li><p>模板</p><ul><li>0 号点既是根节点，又是<strong>空节点</strong></li><li><code>son[][]</code> 存储树中每个节点的<strong>子节点</strong>，实际上所有的点是对应 <code>idx</code></li><li><code>cnt[]</code> 存储以每个节点结尾的单词数量</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> son[N][<span class=hljs-number>26</span>], cnt[N], idx = <span class=hljs-number>0</span>;<br><br><span class=hljs-comment>// 插入字符串</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>insert</span><span class=hljs-params>(<span class=hljs-type>char</span> *str)</span></span>&#123;<br>    <span class=hljs-type>int</span> p = <span class=hljs-number>0</span>;<br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>0</span>; str[i]; i ++)&#123; <br>      <span class=hljs-type>int</span> u = str[i] - <span class=hljs-string>&#x27;a&#x27;</span>;<br>      <span class=hljs-keyword>if</span> (!son[p][u]) son[p][u] = ++ idx;<br>      p = son[p][u];<br>    &#125;<br>    cnt[p] ++;<br>&#125;<br><br><span class=hljs-comment>// 查询字符串出现次数</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>query</span><span class=hljs-params>(<span class=hljs-type>char</span> *str)</span></span>&#123;<br>    <span class=hljs-type>int</span> p = <span class=hljs-number>0</span>;<br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>0</span>; str[i]; i ++)&#123;<br>      <span class=hljs-type>int</span> u = str[i] - <span class=hljs-string>&#x27;u&#x27;</span>;<br>      <span class=hljs-keyword>if</span> (!son[p][u]) <span class=hljs-keyword>return</span> <span class=hljs-number>0</span>;<br>      p = son[p][u];<br>    &#125;<br>    <span class=hljs-keyword>return</span> cnt[p];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id=并查集><a class=markdownIt-Anchor href=#并查集></a> 并查集</h2><ul><li><p>面试中常见，因为<strong>结构简单、构思巧妙</strong></p></li><li><p>解决问题：</p><ol><li>合并：将两个不相交的集合合并位一个集合</li><li>查询：查询两个元素是否在同一个集合中</li></ol></li><li><p>思想：树结构，每个点指向其<strong>父节点</strong></p><ul><li>路径压缩：把<strong>沿途</strong>的每个节点的父节点都设为<strong>祖先节点</strong></li><li>按秩合并：不常见</li></ul></li><li><p>模板</p><ul><li>朴素并查集</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> p[N]; <span class=hljs-comment>// 存储各个节点的祖先节点</span><br><br><span class=hljs-comment>// 返回 x 的祖先节点</span><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>find</span><span class=hljs-params>(<span class=hljs-type>int</span> x)</span></span>&#123;<br>    <span class=hljs-keyword>if</span> (p[x] != x) p[x] = <span class=hljs-built_in>find</span>(p[x]);<br>    <span class=hljs-keyword>return</span> p[x];<br>&#125;<br><br><span class=hljs-comment>// 初始化，节点编号 1~n，各个节点的祖先节点为自己；</span><br><span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n; i ++) p[i] = i;<br><br><span class=hljs-comment>// 合并 a 和 b 所在的集合，相当于让 a 的祖先节点为 b</span><br>p[<span class=hljs-built_in>find</span>(a)] = <span class=hljs-built_in>find</span>(b);<br></code></pre></td></tr></table></figure><ul><li>维护 size 的并查集</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-comment>// p[] 存储各个节点的祖先节点</span><br><span class=hljs-comment>// cnt[] 只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量</span><br><span class=hljs-type>int</span> p[N], cnt[N];<br><br><span class=hljs-comment>// 返回 x 的祖先节点</span><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>find</span><span class=hljs-params>(<span class=hljs-type>int</span> x)</span></span>&#123;<br>    <span class=hljs-keyword>if</span> (p[x] != x) p[x] = <span class=hljs-built_in>find</span>(p[x]);<br>    <span class=hljs-keyword>return</span> p[x];<br>&#125;<br><br><span class=hljs-comment>// 初始化，节点编号 1~n，各个节点的祖先节点为自己；</span><br><span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n; i ++)&#123;<br>    p[i] = i;<br>    cnt[i] = <span class=hljs-number>1</span>;<br>&#125;<br><br><span class=hljs-comment>// 合并 a 和 b 所在的集合，相当于让 a 的祖先节点为 b</span><br>cnt[<span class=hljs-built_in>find</span>(b)] += cnt[<span class=hljs-built_in>find</span>(a)];<br>p[<span class=hljs-built_in>find</span>(a)] = <span class=hljs-built_in>find</span>(b);  <br></code></pre></td></tr></table></figure><ul><li>维护到祖宗节点距离的并查集</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-comment>// p[] 存储各个节点的祖先节点</span><br><span class=hljs-comment>// d[x] 存储 x 到祖先节点的距离</span><br><span class=hljs-type>int</span> p[N], d[N];<br><br><br><span class=hljs-comment>// 返回 x 的祖先节点</span><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>find</span><span class=hljs-params>(<span class=hljs-type>int</span> x)</span></span>&#123;<br>    <span class=hljs-keyword>if</span> (p[x] != x)&#123;<br>        <span class=hljs-type>int</span> u = <span class=hljs-built_in>find</span>(p[x]);<br>        d[x] += d[p[x]];<br>        p[x] = u;<br>    &#125;<br>    <span class=hljs-keyword>return</span> p[x];<br>&#125;<br><br><span class=hljs-comment>// 初始化，节点编号 1~n，各个节点的祖先节点为自己；</span><br><span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n; i ++)&#123;<br>    p[i] = i;<br>    d[i] = <span class=hljs-number>0</span>;<br>&#125;<br><br><span class=hljs-comment>// 合并 a 和 b 所在的集合，相当于让 a 的祖先节点为 b</span><br>p[<span class=hljs-built_in>find</span>(a)] = <span class=hljs-built_in>find</span>(b);  <br>cnt[<span class=hljs-built_in>find</span>(a)] = distance; <span class=hljs-comment>// 根据具体问题，初始化 find(a) 的偏移量</span><br><br></code></pre></td></tr></table></figure></li></ul><h2 id=堆><a class=markdownIt-Anchor href=#堆></a> 堆</h2><ul><li><p>堆：每个节点的值<strong>总是</strong>不大于或不小于其父节点的值</p></li><li><p>堆一定是<strong>完全二叉树</strong>，所以存储方式和之前的<strong>数组模拟链表不同</strong>，采用<strong>下标标记点的位置</strong></p><ul><li>下标为 <code>x</code> 的点的两个左右子节点为 <code>2 * x</code> 和 <code>2 * x + 1</code><ul><li>所以<strong>从 1 开始</strong></li></ul></li></ul></li><li><p>进行 <code>down</code> 操作时必须满足左儿子和右儿子已经是个堆</p></li><li><p>堆排序：不断的取 <code>h[1]</code>，注意堆本身不一定有序，只能保证父子节点之间的单调性</p></li><li><p>模板</p><ul><li><code>h[N]</code>存储堆中的<strong>值</strong>, <code>h[1]</code> 是堆顶，<code>ph[k]</code> 存储第 k 个插入的点在堆中的位置，<code>hp[k]</code> 存储堆中下标是k的点是第几个插入的</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> h[N], hp[N], ph[N], size;<br><br><span class=hljs-comment>// 交换堆中两点及其映射</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>heap_swap</span><span class=hljs-params>(<span class=hljs-type>int</span> a, <span class=hljs-type>int</span> b)</span></span>&#123;<br>    <span class=hljs-built_in>swap</span>(ph[hp[a]], ph[hp[b]]);<br>    <span class=hljs-built_in>swap</span>(hp[a], hp[b]);<br>    <span class=hljs-built_in>swap</span>(h[a], h[b]);<br>&#125;<br><br><span class=hljs-comment>// down 和 up 为基础操作</span><br><br><span class=hljs-comment>// 递归写法</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>down</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span></span>&#123;<br>    <span class=hljs-type>int</span> t = u;<br>    <span class=hljs-keyword>if</span> (u * <span class=hljs-number>2</span> &lt;= size &amp;&amp; h[u * <span class=hljs-number>2</span>] &lt; h[t]) t = u * <span class=hljs-number>2</span>;<br>    <span class=hljs-keyword>if</span> (u * <span class=hljs-number>2</span> + <span class=hljs-number>1</span> &lt;= size &amp;&amp; h[u * <span class=hljs-number>2</span> + <span class=hljs-number>1</span>] &lt; h[t]) t = u * <span class=hljs-number>2</span> + <span class=hljs-number>1</span>;<br>    <span class=hljs-keyword>if</span> (u != t)&#123;<br>      <span class=hljs-built_in>heap_swap</span>(u, t);<br>      <span class=hljs-built_in>down</span>(t);<br>    &#125;<br>&#125;<br><br><span class=hljs-comment>// 循环写法</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>up</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span></span>&#123;<br>    <span class=hljs-keyword>while</span> (u / <span class=hljs-number>2</span> &amp;&amp; h[u]  &lt; h[u / <span class=hljs-number>2</span>])&#123;<br>        <span class=hljs-built_in>heap_swap</span>(u, u / <span class=hljs-number>2</span>);<br>        u &gt;&gt;= <span class=hljs-number>1</span>;<br>    &#125;<br>&#125;<br><br><span class=hljs-comment>// O(n) 建堆，从 n / 2 开始是因为最后的叶节点已经是最下一层</span><br><span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = n / <span class=hljs-number>2</span>; i; i --) <span class=hljs-built_in>down</span>(i);<br><br></code></pre></td></tr></table></figure><ul><li><p>插入一个数</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br></pre></td><td class=code><pre><code class="hljs c++">h[++ size] = x;<br><span class=hljs-built_in>up</span>(x);<br></code></pre></td></tr></table></figure></li><li><p>求集合中最小值</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><code class="hljs c++">h[<span class=hljs-number>1</span>];<br></code></pre></td></tr></table></figure></li><li><p>删除最小值</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><code class="hljs c++">heap[<span class=hljs-number>1</span>] = heap[size];<br>size --;<br><span class=hljs-built_in>down</span>(<span class=hljs-number>1</span>);<br></code></pre></td></tr></table></figure></li><li><p>删除任意一个元素</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br></pre></td><td class=code><pre><code class="hljs c++">heap[k] = heap[size]; <br>size --;<br><span class=hljs-built_in>down</span>(k);<br><span class=hljs-built_in>up</span>(k)<br></code></pre></td></tr></table></figure></li><li><p>修改任意一个元素</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br></pre></td><td class=code><pre><code class="hljs c++">heap[k] = x;<br><span class=hljs-built_in>down</span>(k);<br><span class=hljs-built_in>up</span>(k)<br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id=hash-表><a class=markdownIt-Anchor href=#hash-表></a> Hash 表</h2><h3 id=一般哈希><a class=markdownIt-Anchor href=#一般哈希></a> 一般哈希</h3><ul><li>常用：插入、查询（删除一般是<strong>直接标记</strong>）</li><li>由于把区间变小了，所以一般要<strong>模 N</strong>。因为减少冲突，一般取 N 为素数</li></ul><h4 id=拉链法><a class=markdownIt-Anchor href=#拉链法></a> 拉链法</h4><ul><li><p><code>h[]</code> 中存储对应链表的<code>head</code>头<strong>指针</strong></p></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> h[N], e[N], ne[N], idx;<br><br><span class=hljs-comment>// 向哈希表中插入一个数</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>insert</span><span class=hljs-params>(<span class=hljs-type>int</span> x)</span></span>&#123;<br>  <span class=hljs-type>int</span> k = (k %  N + N) % N; <span class=hljs-comment>// 这么写是因为在 C++ 中负数的模仍然是负数</span><br>  e[idx] = x;<br>  ne[idx] = h[k];<br>  h[k] = idx ++;<br>&#125;<br><br><span class=hljs-comment>// 在哈希表中查询某个数是否存在</span><br><span class=hljs-function><span class=hljs-type>bool</span> <span class=hljs-title>find</span><span class=hljs-params>(<span class=hljs-type>int</span> x)</span></span>&#123;<br>  <span class=hljs-type>int</span> k = (k % N + N) % N;<br>  <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = h[k]; i != <span class=hljs-number>-1</span>; i = ne[i]);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id=开放寻址法><a class=markdownIt-Anchor href=#开放寻址法></a> 开放寻址法</h4><ul><li><p>开放寻址法的好处是不需要<strong>开辟额外的数组</strong>，但是为了减少空间，一般会把 Hash 表的空间开大（约 拉链法 的 2 倍）</p></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> h&#123;N&#125;;<br><br><span class=hljs-comment>// 如果 x 在哈希表中，返回 x 的下标；否则返回 x 应该插入的位置</span><br><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>find</span><span class=hljs-params>(<span class=hljs-type>int</span> x)</span></span>&#123;<br>  <span class=hljs-type>int</span> t = (x % N + N) %N;<br>  <span class=hljs-keyword>while</span>(h[t] != null &amp;&amp; h[t] != x)&#123;<br>    t ++;<br>    <span class=hljs-keyword>if</span>(t == N) t = <span class=hljs-number>0</span>;<br>  &#125;<br>  <span class=hljs-keyword>return</span> t;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id=字符串哈希><a class=markdownIt-Anchor href=#字符串哈希></a> 字符串哈希</h3><ul><li><p>核心思路：将字符串看成 P 进制数</p><ul><li>P 的经验值是 131 或 13331，取这两个值的冲突概率低</li><li>一般我们假设 RP 足够好，不会发生碰撞</li></ul></li><li><p>KMP 的有力竞争对手<br>-小技巧：取模的数用 2^64，这样直接用<code>unsigned long long</code>存储，溢出的结果就是取模的结果</p></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-keyword>typedef</span> <span class=hljs-type>unsigned</span> <span class=hljs-type>long</span> <span class=hljs-type>long</span> ULL;<br>ULL h[N], p[N]; <span class=hljs-comment>// h[k] 存储字符串前 k 个字母的哈希值，p[k] 存储 p^k mod 2^64 便于计算</span><br><br><span class=hljs-comment>// 初始化</span><br>p[<span class=hljs-number>0</span>] = <span class=hljs-number>1</span>;<br><span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n; i ++)&#123;<br>  h[i] = h[i - <span class=hljs-number>1</span>] * P + str[i];<br>  p[i] = p[i - <span class=hljs-number>1</span>] * P;<br>&#125;<br><br><span class=hljs-comment>// 计算字串 str[l ~ r] 的哈希值，这个思想类似于前缀和</span><br><span class=hljs-function>ULL <span class=hljs-title>get</span><span class=hljs-params>(<span class=hljs-type>int</span> l, <span class=hljs-type>int</span> r)</span></span>&#123;<br>  <span class=hljs-keyword>return</span> h[r] - h[l - <span class=hljs-number>1</span>] * p[r - l + <span class=hljs-number>1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><p>算法备忘录系列目录：<br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/ >第一节 算法备忘录·基础算法</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ >第二节 算法备忘录·数据结构</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7STL/ >第三节 算法备忘录·杂项</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/ >第四节 算法备忘录·搜索与图论</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/ >第五节 算法备忘录·数学知识</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/ >第六节 算法备忘录·动态规划</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E8%B4%AA%E5%BF%83/ >第七节 算法备忘录·贪心</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/ >第八节 算法备忘录·时空复杂度分析</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%9D%82%E9%A1%B9/ >第九节 算法备忘录·杂项</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class=category-chains><span class=category-chain><a href=/categories/%E7%AC%94%E8%AE%B0/ class=category-chain-item>笔记</a></span></span></div><div class=post-meta><i class="iconfont icon-tags"></i> <a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/ class=print-no-link>#计算机</a> <a href=/tags/%E7%AE%97%E6%B3%95/ class=print-no-link>#算法</a></div></div><div class="license-box my-3"><div class=license-title><div>算法备忘录·数据结构</div><div>https://justloseit.top/算法备忘录·数据结构/</div></div><div class=license-meta><div class=license-meta-item><div>作者</div><div>Mobilis In Mobili</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2021年8月7日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年5月15日</div></div><div class=license-meta-item><div>许可协议</div><div><a class=print-no-link target=_blank href=https://creativecommons.org/licenses/by-sa/4.0/ ><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i> </span></a><a class=print-no-link target=_blank href=https://creativecommons.org/licenses/by-sa/4.0/ ><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-cc-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href=/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7STL/ title=算法备忘录·STL><i class="iconfont icon-arrowleft"></i> <span class=hidden-mobile>算法备忘录·STL</span> <span class=visible-mobile>上一篇</span></a></article><article class="post-next col-6"><a href=/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/ title=算法备忘录·基础算法><span class=hidden-mobile>算法备忘录·基础算法</span> <span class=visible-mobile>下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id=comments><div id=valine></div><script type=text/javascript>Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",function(){var i=Object.assign({appId:"t4w421aIGl2GXkT0tSGoap5I-gzGzoHsz",appKey:"BpNeeVt0v3tKAbF1L6RTf94X",path:"window.location.pathname",placeholder:"说点什么",avatar:"hide",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!1,serverURLs:"https://t4w421ai.lc-cn-n1-shared.com",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class=sidebar style=margin-left:-1rem><div id=toc><p class=toc-header><i class="iconfont icon-list"></i> <span>目录</span></p><div class=toc-body id=toc-body></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded(function(){Fluid.events.registerRefreshCallback(function(){"mermaid"in window&&mermaid.init()})})})</script><a id=scroll-top-button aria-label=TOP href=# role=button><i class="iconfont icon-arrowup" aria-hidden=true></i></a><div class="modal fade" id=modalSearch tabindex=-1 role=dialog aria-labelledby=ModalLabel aria-hidden=true><div class="modal-dialog modal-dialog-scrollable modal-lg" role=document><div class=modal-content><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type=button id=local-search-close class=close data-dismiss=modal aria-label=Close><span aria-hidden=true>&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type=text id=local-search-input class="form-control validate"> <label data-error=x data-success=v for=local-search-input>关键词</label></div><div class=list-group id=local-search-result></div></div></div></div></div></main><footer><div class=footer-inner><div class=footer-content><a href=https://hexo.io target=_blank rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href=https://github.com/fluid-dev/hexo-theme-fluid target=_blank rel="nofollow noopener"><span>Fluid</span></a></div><div class=statistics><span id=leancloud-site-pv-container style=display:none>总访问量 <span id=leancloud-site-pv></span> 次 </span><span id=leancloud-site-uv-container style=display:none>总访客数 <span id=leancloud-site-uv></span> 人</span></div><div class=beian><span><a href=http://beian.miit.gov.cn/ target=_blank rel="nofollow noopener"><a target=_blank rel=noopener href=https://beian.miit.gov.cn>京ICP备2021006744号-1</a> </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802034644" rel="nofollow noopener" class=beian-police target=_blank><span style=visibility:hidden;width:0>|</span> <img src=/img/police_beian.png alt=police-icon> <span>京公网安备 11010802034644号</span></a></span></div></div></footer><script src=https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js></script><link rel=stylesheet href=https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src=https://lib.baomitu.com/jquery/3.6.4/jquery.min.js></script><script src=https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js></script><script src=/js/events.js></script><script src=/js/plugins.js></script><script src=https://lib.baomitu.com/typed.js/2.0.12/typed.min.js></script><script>(t=>{var e=Fluid.plugins.typing;(t=t.getElementById("subtitle"))&&e&&e(t.getAttribute("data-typed-text"))})((window,document))</script><script src=/js/img-lazyload.js></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer=defer src=/js/leancloud.js></script><script src=/js/local-search.js></script><script src=/js/boot.js></script><noscript><div class=noscript-warning>博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>