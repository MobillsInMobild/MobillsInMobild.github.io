<!DOCTYPE html><html lang=zh-CN data-default-color-scheme=auto><head><meta charset=UTF-8><link rel=apple-touch-icon sizes=76x76 href=/img/favicon/favicon.png><link rel=icon href=/img/favicon/favicon.png><link rel=canonical href=https://justloseit.top/“7天用Go从零实现Web框架Gee”学习记录/ ><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=theme-color content=#2f4154><meta name=author content="Mobilis In Mobili"><meta name=keywords content=""><meta name=description content="开源项目“七天用 Go 从零实现”系列之 Gee-web 学习记录"><meta property=og:type content=article><meta property=og:title content=“7天用Go从零实现Web框架Gee”学习记录><meta property=og:url content=https://justloseit.top/%E2%80%9C7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E2%80%9D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html><meta property=og:site_name content=动中之动><meta property=og:description content="开源项目“七天用 Go 从零实现”系列之 Gee-web 学习记录"><meta property=og:locale content=zh_CN><meta property=og:image content=https://justloseit.top/img/index/%E2%80%9C7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E2%80%9D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.jpg><meta property=article:published_time content=2022-07-03T02:19:04.000Z><meta property=article:modified_time content=2022-11-21T12:07:39.109Z><meta property=article:author content="Mobilis In Mobili"><meta property=article:tag content=编程><meta property=article:tag content=Golang><meta name=twitter:card content=summary_large_image><meta name=twitter:image content=https://justloseit.top/img/index/%E2%80%9C7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E2%80%9D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.jpg><title>“7天用Go从零实现Web框架Gee”学习记录 - 动中之动</title><link rel=stylesheet href=https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css><link rel=stylesheet href=https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css><link rel=stylesheet href=https://lib.baomitu.com/hint.css/2.7.0/hint.min.css><link rel=stylesheet href=https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css><link rel=stylesheet href=//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css><link rel=stylesheet href=//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css><link rel=stylesheet href=/css/main.css><link id=highlight-css rel=stylesheet href=/css/highlight.css><link id=highlight-css-dark rel=stylesheet href=/css/highlight-dark.css><script id=fluid-configs>var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"justloseit.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:60,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"snI2XNrHrhyx5g84m3Uim3EC-gzGzoHsz",app_key:"x2YseXJIHmvnsM4v9y9UAlvu",server_url:"https://sni2xnrh.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src=/js/utils.js></script><script src=/js/color-schema.js></script><meta name=generator content="Hexo 5.4.2"><link rel=alternate href=/atom.xml title=动中之动 type=application/atom+xml></head><body><header><div class=header-inner style=height:70vh><nav id=navbar class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class=container><a class=navbar-brand href=/ ><strong>Mobilis In Mobili</strong> </a><button id=navbar-toggler-btn class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation"><div class=animated-icon><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav ml-auto text-center"><li class=nav-item><a class=nav-link href=/ target=_self><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class=nav-item><a class=nav-link href=/archives/ target=_self><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class=nav-item><a class=nav-link href=/categories/ target=_self><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class=nav-item><a class=nav-link href=/tags/ target=_self><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class=nav-item><a class=nav-link href=/about/ target=_self><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class=nav-item><a class=nav-link href=/links/ target=_self><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class=nav-item id=search-btn><a class=nav-link target=_self href=javascript:; data-toggle=modal data-target=#modalSearch aria-label=Search><i class="iconfont icon-search"></i></a></li><li class=nav-item id=color-toggle-btn><a class=nav-link target=_self href=javascript:; aria-label="Color Toggle"><i class="iconfont icon-dark" id=color-toggle-icon></i></a></li></ul></div></div></nav><div id=banner class=banner parallax=true style="background:url(/img/banner/%E2%80%9C7%E5%A4%A9%E7%94%A8Go%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0Web%E6%A1%86%E6%9E%B6Gee%E2%80%9D%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95.jpg) no-repeat center center;background-size:cover"><div class=full-bg-img><div class="mask flex-center" style=background-color:rgba(0,0,0,.3)><div class="banner-text text-center fade-in-up"><div class=h2><span id=subtitle data-typed-text=“7天用Go从零实现Web框架Gee”学习记录></span></div><div class=mt-3><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden=true></i> Mobilis In Mobili </span><span class=post-meta><i class="iconfont icon-date-fill" aria-hidden=true></i> <time datetime="2022-07-03 10:19" pubdate>2022年7月3日 上午</time></span></div><div class=mt-1><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 2.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 24 分钟 </span><span id=leancloud-page-views-container class=post-meta style=display:none><i class="iconfont icon-eye" aria-hidden=true></i> <span id=leancloud-page-views></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id=board-ctn><div id=board><article class="post-content mx-auto"><h1 id=seo-header>“7天用Go从零实现Web框架Gee”学习记录</h1><p id=updated-time class="note note-info">本文最后更新于 2022年11月21日 晚上</p><div class=markdown-body><p>开源项目“七天用 Go 从零实现”系列之 <a target=_blank rel=noopener href=https://github.com/geektutu/7days-golang/tree/master/gee-web>Gee-web</a> 学习记录</p><span id=more></span><h1 id=7天用go从零实现web框架gee学习记录><a class=markdownIt-Anchor href=#7天用go从零实现web框架gee学习记录></a> “7天用Go从零实现Web框架Gee”学习记录</h1><h2 id=day0-序言><a class=markdownIt-Anchor href=#day0-序言></a> Day0 序言</h2><ul><li>目的：标准库 <code>net/http</code> 仅提供了了端口监听（<em>ListenAndServe</em>）、映射静态路由（<em>HandleFunc</em>）、解析 HTTP 报文的基本功能。Web 框架能够更方便的实现 Web 开发中的一些需求。</li><li>Gee-web 的参考对象：<a target=_blank rel=noopener href=https://github.com/gin-gonic/gin>Gin</a></li></ul><h2 id=day1-http-基础><a class=markdownIt-Anchor href=#day1-http-基础></a> Day1 HTTP 基础</h2><h3 id=标准库启动-web-服务><a class=markdownIt-Anchor href=#标准库启动-web-服务></a> 标准库启动 Web 服务</h3><ul><li><p>利用 <code>handleFunc</code> 设置路由</p></li><li><p>启动 Web 服务，前者代表端口，后者 <code>nil</code> 代表使用标准库中的实例处理（该实例处理所有的HTTP请求）：</p><figure class="highlight go"><table><tr><td class=gutter><pre><span class=line>1</span><br></pre></td><td class=code><pre><code class="hljs go">http.ListenAndServe(<span class=hljs-string>&quot;:9999&quot;</span>, <span class=hljs-literal>nil</span>)<br></code></pre></td></tr></table></figure></li><li><p>测试工具：curl</p></li></ul><h3 id=实现-httphandler-接口><a class=markdownIt-Anchor href=#实现-httphandler-接口></a> 实现 http.Handler 接口</h3><ul><li><p>接口的目的：引入一个新的中间层，避免上下游的耦合，从而实现多态</p></li><li><p><code>net/http</code> 中的 <code>ListenAndServe</code>：</p><figure class="highlight go"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br></pre></td><td class=code><pre><code class="hljs go"><span class=hljs-keyword>package</span> http<br><br><span class=hljs-keyword>type</span> Handler <span class=hljs-keyword>interface</span> &#123;<br>    ServeHTTP(w ResponseWriter, r *Request)<br>&#125;<br><br><span class=hljs-comment>// Handler 是一个接口，需要实现方法 ServeHTTP</span><br><span class=hljs-comment>// 只要传入实现了 ServeHTTP 接口的实例，所有的 HTTP 请求都交给该实例处理</span><br><span class=hljs-function><span class=hljs-keyword>func</span> <span class=hljs-title>ListenAndServe</span><span class=hljs-params>(address <span class=hljs-type>string</span>, h Handler)</span></span> <span class=hljs-type>error</span><br></code></pre></td></tr></table></figure></li><li><p>构造一个实现了 ServeHTTP 接口的实例，让所有的 HTTP 请求由实例处理。这样相当于拦截了<strong>所有 HTTP 请求</strong>，能够进行统一控制，进而自定义处理逻辑（不仅仅局限于之前具体的路由）。</p></li></ul><h3 id=gee-框架的雏形><a class=markdownIt-Anchor href=#gee-框架的雏形></a> Gee 框架的雏形</h3><ul><li><p>代码目录结构</p><figure class="highlight maxima"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><code class="hljs maxima">gee/<br>  |--gee.<span class=hljs-built_in>go</span><br>  |--<span class=hljs-built_in>go</span>.<span class=hljs-built_in>mod</span><br>main.<span class=hljs-built_in>go</span><br><span class=hljs-built_in>go</span>.<span class=hljs-built_in>mod</span><br></code></pre></td></tr></table></figure></li><li><p>在 go.mod 中使用 <code>replace gee =&gt; ./gee</code>，</p><ul><li>从 go 1.11 版本开始，引用相对路径的 package 需要使用上述方式。</li></ul></li><li><p>实现了路由映射表，提供了注册静态路由的方法，包装了启动服务的函数</p><ul><li>定义 <code>HandlerFunc</code> 用来定义路由映射处理方法，供用户注册静态路由。路由映射表 <code>router</code> 为字典，key 遵循“请求方式-静态路由地址”格式，value 对应具体的 <code>HandlerFunc</code> 实例。</li><li>Engine 实现的 <code>Run</code> 方法：对 <code>http.ListenAndServe</code> 包装。</li><li>Engine 实现的 <code>ServeHTTP</code> 方法：解析请求的路径，查找路由映射表，如果查到，就执行注册的 <code>HandlerFunc</code>。如果查不到，就返回 <em>404 NOT FOUND</em>。</li></ul></li></ul><h2 id=day2-上下文-context><a class=markdownIt-Anchor href=#day2-上下文-context></a> Day2 上下文 Context</h2><h3 id=使用效果><a class=markdownIt-Anchor href=#使用效果></a> 使用效果</h3><ul><li>将 <code>Handler</code> 参数变成 <code>gee.Context</code>，提供查询 Query/PostForm 参数的功能。</li><li><code>gee.Context</code> 封装了 <code>HTML/String/JSON</code> 函数，能够快速构造 HTTP 响应。</li></ul><h3 id=设计-context><a class=markdownIt-Anchor href=#设计-context></a> 设计 Context</h3><h4 id=必要性><a class=markdownIt-Anchor href=#必要性></a> 必要性</h4><ul><li>如果直接使用 <code>Hhttp.ResponseWriter, *http.Request</code>，粒度太细，用户需要些大量重复的代码。</li><li>此外，Context 随着每一个请求的出现而产生，请求的结束而销毁，<strong>和当前请求强相关的信息都应由 Context 承载</strong>。设计 Context 结构能将将扩展性和复杂性留在内部，对外简化接口，这样才能支撑额外的功能（解析动态路由 <code>/hello/:hello</code> 中参数<code>:hello</code>等等）。</li></ul><h4 id=具体实现><a class=markdownIt-Anchor href=#具体实现></a> 具体实现</h4><ul><li>使用 <code>map[string]interface&#123;&#125;</code> 保存 JSON 数据，因为<strong>空接口类型可以保存任何值，也可以从空接口中取出原值</strong>，一种非常灵活的数据抽象保存和使用的方法。</li><li><code>json.NewEncoder</code> 在<strong>流</strong>中进行编码，<code>json.Marshal</code> 对 <strong>[]byte</strong> 进行编码。</li></ul><h3 id=路由router><a class=markdownIt-Anchor href=#路由router></a> 路由（Router）</h3><ul><li>将路由相关的方法的结构提取出来，方便下一次对 router 功能进行增强。</li><li><code>handler</code> 的参数变成了 <code>Context</code>。</li></ul><h3 id=框架入口><a class=markdownIt-Anchor href=#框架入口></a> 框架入口</h3><ul><li>通过独立 <code>Router</code> 相关的代码，使 <code>gee.go</code> 精简。</li></ul><h2 id=day3-前缀树路由-router><a class=markdownIt-Anchor href=#day3-前缀树路由-router></a> Day3 前缀树路由 Router</h2><ul><li>通过 <strong>Trie 树</strong>实现动态路由解析。<ul><li>动态路由支持 <code>:name</code> 和 <code>*filepath</code> 两种模式 。</li></ul></li></ul><h3 id=trie-树简介><a class=markdownIt-Anchor href=#trie-树简介></a> Trie 树简介</h3><ul><li>之前使用的 <code>map</code> 结构存储路由表仅能用来索引静态路由，而动态路由需要路由规则匹配某一类型路由而非某一固定路由，因此需要调整存储结构。</li><li>Trie 树：每个节点的所有子节点都具有相同的前缀。<ul><li>HTTP 的请求路径恰好是用 <code>/</code> 分隔，可以每段作为前缀树的一个节点。</li></ul></li></ul><h3 id=trie-树实现><a class=markdownIt-Anchor href=#trie-树实现></a> Trie 树实现</h3><ul><li>为了实现动态路由匹配，引入 <code>isWild</code> 参数，是为了让 <code>/go/:name1/:name2</code> 这种路径中的 <code>/:name1</code> 被模糊匹配后视为 <code>/go</code> ，继续下一层匹配。</li><li>路由服务 = 注册 + 匹配<ul><li>对应 Trie 树节点的插入和查询<ul><li>插入：递归查找节点，如果没有当前 <code>part</code> 的节点，则新建一个。</li><li>查询：递归查找节点，匹配到 <code>*</code> 或者匹配到第 <code>len(parts)</code> 层节点。</li></ul></li></ul></li></ul><h3 id=router><a class=markdownIt-Anchor href=#router></a> Router</h3><ul><li><code>roots</code> 存储每种匹配方式的 Tier 树根节点，<code>handlers</code> 存储每种请求方式的 <code>HandlerFunc</code>。</li><li><code>getRoute</code> 函数用来解析 <code>:name</code> 和 <code>*filepath</code> 两种通配符的参数。</li></ul><h3 id=context-与-handle-的变化><a class=markdownIt-Anchor href=#context-与-handle-的变化></a> Context 与 handle 的变化</h3><ul><li><code>Context</code> 对象新增对路由参数访问的支持，存储在 <code>Params</code> 中。</li></ul><h3 id=单元测试><a class=markdownIt-Anchor href=#单元测试></a> 单元测试</h3><ul><li><p>单元测试文件以 <code>_test.go</code> 结尾。</p></li><li><p>测试用例名称一般命名为 <strong>Test + 待测试的方法名</strong>。</p></li><li><p>测试用的参数有且只有一个，在这里是 <code>*testing.T</code>。</p><ul><li>benchmark 的参数是 <code>*testing.B</code> 类型，TestMain 的参数是 <code>*testing.M</code> 类型。</li></ul></li><li><p>命令行：</p><figure class="highlight bash"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><code class="hljs bash"><span class=hljs-comment># 测试该 package 下所有的测试用例</span><br>go <span class=hljs-built_in>test</span><br><span class=hljs-comment># -v 参数查看每个用例测试结果，-cover 参数查看覆盖率</span><br>go <span class=hljs-built_in>test</span> -v -cover<br><span class=hljs-comment># -run 指定特定用例，支持通配符和部分正则表达式</span><br>go <span class=hljs-built_in>test</span> -run TestName <br></code></pre></td></tr></table></figure></li><li><p><code>reflect.DeepEqual</code> 可以用来比较<strong>结构体</strong></p></li></ul><h2 id=day4-分组控制-group><a class=markdownIt-Anchor href=#day4-分组控制-group></a> Day4 分组控制 Group</h2><h3 id=分组的意义><a class=markdownIt-Anchor href=#分组的意义></a> 分组的意义</h3><ul><li>分组控制能够让<strong>某组</strong>路由以及其<strong>子分组</strong>具有相似的处理，例如对 <code>/post</code> 开头的路由匿名可访问。对于子分组 <code>/post/a</code>，它在路由匿名可访问的基础上，还可以应用自己特有的中间件。</li></ul><h3 id=分组嵌套><a class=markdownIt-Anchor href=#分组嵌套></a> 分组嵌套</h3><ul><li>一个 <code>Group</code> 对象应该具备的属性：<ul><li>前缀 <code>/api</code></li><li>分组的父亲 <code>parent</code>（为了支持分组嵌套）</li><li>中间件 <code>middlewares</code></li><li>指向 <code>Engine</code> 的指针，因为 <code>Engine</code> 是框架统一入口，这样可以间接访问其他各种接口</li></ul></li><li><code>Group</code> 的定义：</li></ul><figure class="highlight go"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br></pre></td><td class=code><pre><code class="hljs go">RouterGroup <span class=hljs-keyword>struct</span> &#123;<br> prefix      <span class=hljs-type>string</span><br> middlewares []HandlerFunc <span class=hljs-comment>// support middleware</span><br> parent      *RouterGroup  <span class=hljs-comment>// support nesting</span><br> engine      *Engine       <span class=hljs-comment>// all groups share a Engine instance</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>Engine</code> 作为最顶层的分组，拥有 <code>RouteGroup</code> 的<strong>所有能力</strong></li></ul><figure class="highlight go"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><code class="hljs go">Engine <span class=hljs-keyword>struct</span> &#123;<br> *RouterGroup<br> router *router<br> groups []*RouterGroup <span class=hljs-comment>// store all groups</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id=day5-中间件-middleware><a class=markdownIt-Anchor href=#day5-中间件-middleware></a> Day5 中间件 Middleware</h2><h3 id=中间件是什么><a class=markdownIt-Anchor href=#中间件是什么></a> 中间件是什么</h3><ul><li>中间件是框架提供的<strong>插口</strong>，用于用户自己定义功能</li><li>需要考虑的点：<ul><li>插入点如果太底层，中间件的逻辑会非常复杂；如果离用户太近，和用户直接定义一组函数直接在 <code>Handler</code> 中调用区别不大。</li><li>中间件的输入决定了其<strong>扩展能力</strong>。暴露的参数太少，扩展能力有限。</li></ul></li></ul><h3 id=中间件设计><a class=markdownIt-Anchor href=#中间件设计></a> 中间件设计</h3><ul><li>中间件的定义和路由映射的 <code>Handler</code> 一致，输入均为 <code>Context</code> 对象。插入点是<strong>框架接收到请求初始化 <code>Context</code>后</strong>，允许用户使用自定义的中间件做一些额外处理。</li><li><code>(*Context).Next()</code> 函数用于用户自己定义的 <code>Handler</code> <strong>处理结束后</strong>，再进行额外操作。</li><li>综合上述，设计的中间件支持用户在请求被处理的<strong>前后</strong>，做出额外的操作。</li><li>框架设计：当接收到请求后，匹配路由，<strong>查找应作用于该路由的中间件</strong>，该请求的所有信息都保存在 <code>Context</code> 中（<strong>因为处理结束后还可以调用</strong>）。</li></ul><figure class="highlight go"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre></td><td class=code><pre><code class="hljs go"><span class=hljs-keyword>type</span> Context <span class=hljs-keyword>struct</span> &#123;<br> <span class=hljs-comment>// origin objects</span><br> Writer http.ResponseWriter<br> Req    *http.Request<br> <span class=hljs-comment>// request info</span><br> Path   <span class=hljs-type>string</span><br> Method <span class=hljs-type>string</span><br> Params <span class=hljs-keyword>map</span>[<span class=hljs-type>string</span>]<span class=hljs-type>string</span><br> <span class=hljs-comment>// response info</span><br> StatusCode <span class=hljs-type>int</span><br> <span class=hljs-comment>// middleware</span><br> handlers []HandlerFunc<br> index    <span class=hljs-type>int</span><br>&#125;<br><br><span class=hljs-comment>// 对设置多个中间件依次进行调用</span><br><span class=hljs-function><span class=hljs-keyword>func</span> <span class=hljs-params>(c *Context)</span></span> Next() &#123;<br> c.index++<br> s := <span class=hljs-built_in>len</span>(c.handlers)<br> <span class=hljs-keyword>for</span> ; c.index &lt; s; c.index++ &#123;<br>  c.handlers[c.index](c)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>index</code> 记录当前执行到第几个中间件，当中间件调用 <code>Next</code> 方法时，控制权<strong>交给下一个中间件</strong>，直到调用到最后一个中间件，再从后往前，调用各个中间件<strong>在 <code>Next</code> 方法之后定义的部分</strong>。</p><ul><li>例如：定义中间件 A、B 和路由映射 <em>Handler</em>，<code>c.handlers</code>=[A,B,<em>Handler</em> ]，<code>c.index</code> = -1，调用 <code>c.Next()</code>。对应的流程为：<strong>part1 -&gt; part3 -&gt; <em>Handler</em> -&gt; part 4 -&gt; part2</strong></li></ul><figure class="highlight go"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br></pre></td><td class=code><pre><code class="hljs go"><span class=hljs-function><span class=hljs-keyword>func</span> <span class=hljs-title>A</span><span class=hljs-params>(c *Context)</span></span> &#123;<br>  part1<br>  c.Next()<br>  part2<br>&#125;<br><span class=hljs-function><span class=hljs-keyword>func</span> <span class=hljs-title>B</span><span class=hljs-params>(c *Context)</span></span> &#123;<br>    part3<br>    c.Next()<br>    part4<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id=代码实现><a class=markdownIt-Anchor href=#代码实现></a> 代码实现</h3><ul><li>定义 <code>use</code> 函数，将中间件应用到某个 Group。</li><li>修改 ServeHTTP：当收到一个具体请求时，通过 URL 前缀判断请求适用于哪些中间件，得到中间件列表后赋值给 <code>c.handlers</code>。</li></ul><h2 id=day6-模板-template><a class=markdownIt-Anchor href=#day6-模板-template></a> Day6 模板 Template</h2><h3 id=服务端渲染><a class=markdownIt-Anchor href=#服务端渲染></a> 服务端渲染</h3><ul><li>日益流行的前后端分离的开发模式：Web 后端提供 <strong>RESTful 接口</strong>，返回结构化的数据（一般为 JSON 或者 XML）。前端使用 <strong>AJAX 技术</strong>请求到所需的数据，利用 JavaScript 进行渲染。<ul><li>这样能够前后端解耦，方便开发。</li><li>但是由于页面是在<strong>客户端渲染</strong>的，对爬虫并不友好。</li></ul></li><li>Day6 的内容即是如何让 Web 框架支持服务端渲染的场景。</li></ul><h3 id=静态文件-serve-static-files><a class=markdownIt-Anchor href=#静态文件-serve-static-files></a> 静态文件 Serve Static Files</h3><ul><li>要做到服务器渲染，第一步是要支持 JS、CSS 等静态文件。</li><li>之前设计动态路由的时候，已支持 <code>*filepath</code> 模式，它能够获得文件的相对位置。如果我们将静态文件放到指定目录，那么映射到真实文件后，将文件返回则实现了静态服务器。</li><li>而 <code>net/http</code> 库已经实现了文件返回的功能。只需要把文件真实位置交给 <code>http.FileServer</code> 即可。</li></ul><h3 id=html-模板渲染><a class=markdownIt-Anchor href=#html-模板渲染></a> HTML 模板渲染</h3><ul><li>Go 语言内置 <code>text/template</code> 和 <code>html/template</code> 两个模板标准库，Gee -Web 直接使用 <code>html/template</code> 即可。</li></ul><h2 id=day7-错误恢复-panic-recover><a class=markdownIt-Anchor href=#day7-错误恢复-panic-recover></a> Day7 错误恢复 Panic Recover</h2><ul><li>实现错误处理机制</li></ul><h3 id=panic><a class=markdownIt-Anchor href=#panic></a> panic</h3><ul><li>Go 中错误处理<ul><li>返回 Error，由调用者决定后续如何处理</li><li>触发 panic，<strong>中止</strong>当前执行的程序，退出<ul><li>数组越界等错误，也是触发 panic</li></ul></li></ul></li></ul><h3 id=defer><a class=markdownIt-Anchor href=#defer></a> defer</h3><ul><li>panic 会导致程序中止，但是会<strong>先处理完当前协程上已经 defer 的任务</strong>，执行完成后再退出。<ul><li>类似于 <code>try ... catch</code></li></ul></li><li>可以 defer 多个任务，在同一个函数中 defer 多个任务会<strong>逆序执行</strong></li></ul><h3 id=recover><a class=markdownIt-Anchor href=#recover></a> recover</h3><ul><li>recover 函数可以避免因为 panic 发生导致整个程序终止</li><li>recover 函数<strong>只在 defer 中生效</strong></li></ul><h3 id=gee-的错误处理机制><a class=markdownIt-Anchor href=#gee-的错误处理机制></a> Gee 的错误处理机制</h3><ul><li><p>为 Gee-web 添加一个简单的错误处理机制：当错误发生时，向用户返回 <em>Internal Server Error</em>，并在日志中打印</p></li><li><p>错误处理作为一个中间件 <code>Recovery</code>，使用 defer 挂载上错误恢复的函数。该函数调用 <code>recover()</code>，捕获 panic 并将堆栈信息打印到日志，向用户返回 <em>Internal Server Error</em></p><ul><li>使用 <code>trace()</code> 函数：这个函数能够获取触发 panic 的堆栈信息</li></ul><figure class="highlight go"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br><span class=line>38</span><br><span class=line>39</span><br></pre></td><td class=code><pre><code class="hljs go"><span class=hljs-comment>// 获取触发 panic 的堆栈信息</span><br><span class=hljs-function><span class=hljs-keyword>func</span> <span class=hljs-title>trace</span><span class=hljs-params>(message <span class=hljs-type>string</span>)</span></span> <span class=hljs-type>string</span> &#123;<br>  <span class=hljs-keyword>var</span> pcs [<span class=hljs-number>32</span>]<span class=hljs-type>uintptr</span><br><br>  <span class=hljs-comment>// Callers 用来返回堆栈的程序计数器</span><br>  <span class=hljs-comment>// 第 0 个 Callers 是 Callers 本身</span><br>  <span class=hljs-comment>// 第 1 个是上一层 trace()</span><br>  <span class=hljs-comment>// 第 2 个是 defer func</span><br>  <span class=hljs-comment>// 为了日志简洁，跳过前三个 Callers</span><br>  n := runtime.Callers(<span class=hljs-number>3</span>, pcs[:]) <br><br>  <span class=hljs-keyword>var</span> str strings.Builder<br>  str.WriteString(message + <span class=hljs-string>&quot;\nTraceback:&quot;</span>)<br>  <span class=hljs-keyword>for</span> _, pc := <span class=hljs-keyword>range</span> pcs[:n] &#123;<br>    <span class=hljs-comment>// 获取对应的函数</span><br>    fn := runtime.FuncForPC(pc)<br>    <span class=hljs-comment>// 获取调用该函数 文件名和行号</span><br>    file, line := fn.FileLine(pc)<br>    str.WriteString(fmt.Sprintf(<span class=hljs-string>&quot;\n\t%s:%d&quot;</span>, file, line))<br>  &#125;<br>  <span class=hljs-keyword>return</span> str.String()<br>&#125;<br><br><br><span class=hljs-function><span class=hljs-keyword>func</span> <span class=hljs-title>Recovery</span><span class=hljs-params>()</span></span> HandlerFunc &#123;<br>  <span class=hljs-keyword>return</span> <span class=hljs-function><span class=hljs-keyword>func</span><span class=hljs-params>(c *Context)</span></span> &#123;<br>    <span class=hljs-comment>// 第 2 个 Caller</span><br>    <span class=hljs-keyword>defer</span> <span class=hljs-function><span class=hljs-keyword>func</span><span class=hljs-params>()</span></span> &#123;<br>      <span class=hljs-keyword>if</span> err := <span class=hljs-built_in>recover</span>(); err != <span class=hljs-literal>nil</span> &#123;<br>        message := fmt.Sprintf(<span class=hljs-string>&quot;%s&quot;</span>, err)<br>        <span class=hljs-comment>// 第 1 个 Caller</span><br>        log.Printf(<span class=hljs-string>&quot;%s\n\n&quot;</span>, trace(message))<br>        c.Fail(http.StatusInternalServerError, <span class=hljs-string>&quot;Internal Server Error&quot;</span>)<br>      &#125;<br>    &#125;()<br><br>    c.Next()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id=总结><a class=markdownIt-Anchor href=#总结></a> 总结</h2><ul><li>第一次看这种开源项目的源码，学习它的思路和写法，感觉还是收获颇多的。对我而言，Gee-web 让我理解了<strong>Web 框架的工作原理</strong>，学习了如何通过引入<strong>上下文和中间件</strong>实现<strong>框架的接口和扩展</strong>。一些语言使用方式，例如 Go test、Go 的错误恢复等，也了解到怎么将项目代码专业化。</li><li>对整个项目印象最为深刻的还是<strong>接口型函数</strong>的广泛使用，它的使用更加灵活，可读性也更好，<strong>方便传入函数作为参数</strong>。<code>Handler</code> 就是一个典型的接口型函数，而 <code>HandleFunc</code> 则是能够将普通的函数类型/结构体进行转换。</li></ul></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class=category-chains><span class=category-chain><a href=/categories/%E7%AC%94%E8%AE%B0/ class=category-chain-item>笔记</a></span></span></div><div class=post-meta><i class="iconfont icon-tags"></i> <a href=/tags/%E7%BC%96%E7%A8%8B/ class=print-no-link>#编程</a> <a href=/tags/Golang/ class=print-no-link>#Golang</a></div></div><div class="license-box my-3"><div class=license-title><div>“7天用Go从零实现Web框架Gee”学习记录</div><div>https://justloseit.top/“7天用Go从零实现Web框架Gee”学习记录/</div></div><div class=license-meta><div class=license-meta-item><div>作者</div><div>Mobilis In Mobili</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2022年7月3日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2022年11月21日</div></div><div class=license-meta-item><div>许可协议</div><div><a class=print-no-link target=_blank href=https://creativecommons.org/licenses/by/4.0/ ><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href=/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%85%B1%E8%AF%86%E4%B8%AD%E7%9A%84%E2%80%9C%E8%9C%9C%E7%8D%BE%E2%80%9D/ title=拜占庭共识中的“蜜獾”><i class="iconfont icon-arrowleft"></i> <span class=hidden-mobile>拜占庭共识中的“蜜獾”</span> <span class=visible-mobile>上一篇</span></a></article><article class="post-next col-6"><a href=/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%88%86%E7%89%87%E6%8A%80%E6%9C%AF%E7%BB%BC%E8%BF%B0/ title=区块链分片技术综述><span class=hidden-mobile>区块链分片技术综述</span> <span class=visible-mobile>下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id=comments><div id=valine></div><script type=text/javascript>Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",function(){var i=Object.assign({appId:"t4w421aIGl2GXkT0tSGoap5I-gzGzoHsz",appKey:"BpNeeVt0v3tKAbF1L6RTf94X",path:"window.location.pathname",placeholder:"说点什么",avatar:"hide",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!1,serverURLs:"https://t4w421ai.lc-cn-n1-shared.com",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class=sidebar style=margin-left:-1rem><div id=toc><p class=toc-header><i class="iconfont icon-list"></i> <span>目录</span></p><div class=toc-body id=toc-body></div></div></aside></div></div></div><a id=scroll-top-button aria-label=TOP href=# role=button><i class="iconfont icon-arrowup" aria-hidden=true></i></a><div class="modal fade" id=modalSearch tabindex=-1 role=dialog aria-labelledby=ModalLabel aria-hidden=true><div class="modal-dialog modal-dialog-scrollable modal-lg" role=document><div class=modal-content><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type=button id=local-search-close class=close data-dismiss=modal aria-label=Close><span aria-hidden=true>&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type=text id=local-search-input class="form-control validate"> <label data-error=x data-success=v for=local-search-input>关键词</label></div><div class=list-group id=local-search-result></div></div></div></div></div></main><footer><div class=footer-inner><div class=footer-content><a href=https://hexo.io target=_blank rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href=https://github.com/fluid-dev/hexo-theme-fluid target=_blank rel="nofollow noopener"><span>Fluid</span></a></div><div class=statistics><span id=leancloud-site-pv-container style=display:none>总访问量 <span id=leancloud-site-pv></span> 次 </span><span id=leancloud-site-uv-container style=display:none>总访客数 <span id=leancloud-site-uv></span> 人</span></div><div class=beian><span><a href=http://beian.miit.gov.cn/ target=_blank rel="nofollow noopener"><a target=_blank rel=noopener href=https://beian.miit.gov.cn>京ICP备2021006744号-1</a> </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802034644" rel="nofollow noopener" class=beian-police target=_blank><span style=visibility:hidden;width:0>|</span> <img src=/img/police_beian.png alt=police-icon> <span>京公网安备 11010802034644号</span></a></span></div></div></footer><script src=https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js></script><link rel=stylesheet href=https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src=https://lib.baomitu.com/jquery/3.6.4/jquery.min.js></script><script src=https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js></script><script src=/js/events.js></script><script src=/js/plugins.js></script><script src=https://lib.baomitu.com/typed.js/2.0.12/typed.min.js></script><script>(t=>{var e=Fluid.plugins.typing;(t=t.getElementById("subtitle"))&&e&&e(t.getAttribute("data-typed-text"))})((window,document))</script><script src=/js/img-lazyload.js></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer=defer src=/js/leancloud.js></script><script src=/js/local-search.js></script><script src=/js/boot.js></script><noscript><div class=noscript-warning>博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>