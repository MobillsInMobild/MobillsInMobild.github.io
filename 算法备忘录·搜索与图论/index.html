<!DOCTYPE html><html lang=zh-CN data-default-color-scheme=auto><head><meta charset=UTF-8><link rel=apple-touch-icon sizes=76x76 href=/img/favicon/favicon.png><link rel=icon href=/img/favicon/favicon.png><link rel=canonical href=https://justloseit.top/算法备忘录·搜索与图论/ ><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=theme-color content=#2f4154><meta name=author content="Mobilis In Mobili"><meta name=keywords content=""><meta name=description content="一直以来，没能系统学习算法，是我心中的痛；现在学了 y 总的算法基础课，做做笔记，希望能够有所收获。 这是第四节，搜索与图论。"><meta property=og:type content=article><meta property=og:title content=算法备忘录·搜索与图论><meta property=og:url content=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/index.html><meta property=og:site_name content=动中之动><meta property=og:description content="一直以来，没能系统学习算法，是我心中的痛；现在学了 y 总的算法基础课，做做笔记，希望能够有所收获。 这是第四节，搜索与图论。"><meta property=og:locale content=zh_CN><meta property=og:image content=https://justloseit.top/img/index/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.jpg><meta property=article:published_time content=2021-08-21T12:46:25.000Z><meta property=article:modified_time content=2024-05-14T17:36:43.144Z><meta property=article:author content="Mobilis In Mobili"><meta property=article:tag content=计算机><meta property=article:tag content=算法><meta name=twitter:card content=summary_large_image><meta name=twitter:image content=https://justloseit.top/img/index/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.jpg><title>算法备忘录·搜索与图论 - 动中之动</title><link rel=stylesheet href=https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css><link rel=stylesheet href=https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css><link rel=stylesheet href=https://lib.baomitu.com/hint.css/2.7.0/hint.min.css><link rel=stylesheet href=https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css><link rel=stylesheet href=https://lib.baomitu.com/KaTeX/0.16.2/katex.min.css><link rel=stylesheet href=//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css><link rel=stylesheet href=//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css><link rel=stylesheet href=/css/main.css><link id=highlight-css rel=stylesheet href=/css/highlight.css><link id=highlight-css-dark rel=stylesheet href=/css/highlight-dark.css><script id=fluid-configs>var dntVal,Fluid=window.Fluid||{},CONFIG=(Fluid.ctx=Object.assign({},Fluid.ctx),{hostname:"justloseit.top",root:"/",version:"1.9.8",typing:{enable:!0,typeSpeed:60,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"right",visible:"hover",icon:"§"},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!0,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!0,follow_dnt:!1,baidu:null,google:{measurement_id:null},tencent:{sid:null,cid:null},leancloud:{app_id:"snI2XNrHrhyx5g84m3Uim3EC-gzGzoHsz",app_key:"x2YseXJIHmvnsM4v9y9UAlvu",server_url:"https://sni2xnrh.lc-cn-n1-shared.com",path:"window.location.pathname",ignore_local:!1},umami:{src:null,website_id:null,domains:null,start_time:"2024-01-01T00:00:00.000Z",token:null,api_server:null}},search_path:"/local-search.xml",include_content_in_search:!0});CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src=/js/utils.js></script><script src=/js/color-schema.js></script><meta name=generator content="Hexo 5.4.2"><link rel=alternate href=/atom.xml title=动中之动 type=application/atom+xml></head><body><header><div class=header-inner style=height:70vh><nav id=navbar class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class=container><a class=navbar-brand href=/ ><strong>Mobilis In Mobili</strong> </a><button id=navbar-toggler-btn class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation"><div class=animated-icon><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="navbar-nav ml-auto text-center"><li class=nav-item><a class=nav-link href=/ target=_self><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class=nav-item><a class=nav-link href=/archives/ target=_self><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class=nav-item><a class=nav-link href=/categories/ target=_self><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class=nav-item><a class=nav-link href=/tags/ target=_self><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class=nav-item><a class=nav-link href=/about/ target=_self><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class=nav-item><a class=nav-link href=/links/ target=_self><i class="iconfont icon-link-fill"></i> <span>友链</span></a></li><li class=nav-item id=search-btn><a class=nav-link target=_self href=javascript:; data-toggle=modal data-target=#modalSearch aria-label=Search><i class="iconfont icon-search"></i></a></li><li class=nav-item id=color-toggle-btn><a class=nav-link target=_self href=javascript:; aria-label="Color Toggle"><i class="iconfont icon-dark" id=color-toggle-icon></i></a></li></ul></div></div></nav><div id=banner class=banner parallax=true style="background:url(/img/banner/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA.jpg) no-repeat center center;background-size:cover"><div class=full-bg-img><div class="mask flex-center" style=background-color:rgba(0,0,0,.3)><div class="banner-text text-center fade-in-up"><div class=h2><span id=subtitle data-typed-text=算法备忘录·搜索与图论></span></div><div class=mt-3><span class="post-meta mr-2"><i class="iconfont icon-author" aria-hidden=true></i> Mobilis In Mobili </span><span class=post-meta><i class="iconfont icon-date-fill" aria-hidden=true></i> <time datetime="2021-08-21 20:46" pubdate>2021年8月21日 晚上</time></span></div><div class=mt-1><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.5k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 29 分钟 </span><span id=leancloud-page-views-container class=post-meta style=display:none><i class="iconfont icon-eye" aria-hidden=true></i> <span id=leancloud-page-views></span> 次</span></div></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id=board-ctn><div id=board><article class="post-content mx-auto"><h1 id=seo-header>算法备忘录·搜索与图论</h1><p id=updated-time class="note note-info">本文最后更新于 2024年5月15日 凌晨</p><div class=markdown-body><p>一直以来，没能系统学习算法，是我心中的痛；现在学了 y 总的算法基础课，做做笔记，希望能够有所收获。<br>这是第四节，搜索与图论。</p><span id=more></span><h1 id=搜索与图论><a class=markdownIt-Anchor href=#搜索与图论></a> 搜索与图论</h1><h2 id=图的搜索><a class=markdownIt-Anchor href=#图的搜索></a> 图的搜索</h2><table><thead><tr><th style=text-align:center>搜索</th><th style=text-align:center>数据结构</th><th style=text-align:center>空间</th><th style=text-align:center>优劣</th></tr></thead><tbody><tr><td style=text-align:center>DFS</td><td style=text-align:center>stack</td><td style=text-align:center>O(h)</td><td style=text-align:center>不具有最短性</td></tr><tr><td style=text-align:center>BFS</td><td style=text-align:center>queue</td><td style=text-align:center>O(2^h)</td><td style=text-align:center>“最短路”</td></tr></tbody></table><h3 id=dfs><a class=markdownIt-Anchor href=#dfs></a> DFS</h3><ul><li><strong>顺序</strong>——搜索树<ul><li>递归（系统帮我们维护了栈）—— 回溯（<strong>从递归出来</strong>后还原现场）<ul><li>剪枝：递归过程中能够直接判断然后回溯</li></ul></li></ul></li><li>一般无通用框架，关键是<strong>搜索的顺序</strong></li></ul><h3 id=bfs><a class=markdownIt-Anchor href=#bfs></a> BFS</h3><ul><li><p>能够搜索到最短（边的权重为 1）</p></li><li><p>有通用的框架</p><figure class="highlight cpp"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br></pre></td><td class=code><pre><code class="hljs cpp">queue ← 初始状态<br><span class=hljs-keyword>while</span> (queue 不空)&#123;<br>    t ← 队头<br>    扩展队头<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id=图的存储><a class=markdownIt-Anchor href=#图的存储></a> 图的存储</h2><ul><li>有向图、无向图（无向图就当作双向有向图）</li></ul><h3 id=邻接矩阵><a class=markdownIt-Anchor href=#邻接矩阵></a> 邻接矩阵</h3><ul><li><code>g[a][b]</code> 存储边 a-&gt;b</li></ul><h3 id=邻接表><a class=markdownIt-Anchor href=#邻接表></a> 邻接表</h3><ul><li><p>每个点有一个单链表，类似于<strong>拉链法</strong></p></li><li><p><strong>使用的邻接表的 TLE 极可能是没有初始化 <code>h[]</code></strong></p></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-comment>// 对每个节点 k，开单链表，存储其能够走到的所有点。h[k] 存储单链表的头节点</span><br><span class=hljs-type>int</span> h[N], e[N], ne[N], idx;<br><br><span class=hljs-comment>//添加一条边 a -&gt; b</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>add</span><span class=hljs-params>(<span class=hljs-type>int</span> a, <span class=hljs-type>int</span> b)</span></span>&#123;<br>    e[idx] = b, ne[idx] = h[a], h[a] = idx ++;<br>&#125;<br><br><span class=hljs-comment>// 初始化</span><br>idx = <span class=hljs-number>0</span>;<br><span class=hljs-built_in>memset</span>(h, <span class=hljs-number>-1</span>, <span class=hljs-keyword>sizeof</span> h);<br></code></pre></td></tr></table></figure></li></ul><h2 id=图的遍历><a class=markdownIt-Anchor href=#图的遍历></a> 图的遍历</h2><ul><li>时间复杂度为 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(n + m)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">n</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault">m</span><span class=mclose>)</span></span></span></span>，<span class=katex><span class=katex-mathml><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=application/x-tex>n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">n</span></span></span></span> 表示点数，<span class=katex><span class=katex-mathml><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=application/x-tex>m</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">m</span></span></span></span> 表示边数</li></ul><h3 id=深度优先遍历><a class=markdownIt-Anchor href=#深度优先遍历></a> 深度优先遍历</h3><ul><li><p>遍历不需要恢复现场</p></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>dfs</span><span class=hljs-params>(<span class=hljs-type>int</span> u)</span></span>&#123;<br>    st[u] == <span class=hljs-literal>true</span>; <span class=hljs-comment>// st[u] 表示点 u 已经被遍历过</span><br>  <br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = h[u]; i != <span class=hljs-number>-1</span>; i = ne[i])&#123;<br>        <span class=hljs-type>int</span> j = e[i];<br>        <span class=hljs-keyword>if</span> (!st[j]) <span class=hljs-built_in>dfs</span>(j); <span class=hljs-comment>//不需要恢复现场</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id=宽度优先遍历><a class=markdownIt-Anchor href=#宽度优先遍历></a> 宽度优先遍历</h3><ul><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br></pre></td><td class=code><pre><code class="hljs c++">queue&lt;<span class=hljs-type>int</span>&gt; q;<br><br>st[<span class=hljs-number>1</span>];<br>q.<span class=hljs-built_in>push</span>(<span class=hljs-number>1</span>);<br><br><span class=hljs-keyword>while</span>(q.<span class=hljs-built_in>size</span>())&#123;<br>    <span class=hljs-type>int</span> t = q.<span class=hljs-built_in>front</span>();<br>    q.<span class=hljs-built_in>pop</span>();<br>  <br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = h[t]; i != <span class=hljs-number>-1</span>; i = ne[i])&#123;<br>        <span class=hljs-type>int</span> j = e[i];<br>        <span class=hljs-keyword>if</span> (!st[j])&#123;<br>          st[j] = <span class=hljs-literal>true</span>; <span class=hljs-comment>// 表示点 j 已经被遍历过</span><br>          q.<span class=hljs-built_in>push</span>(j);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id=有向图的拓扑序列><a class=markdownIt-Anchor href=#有向图的拓扑序列></a> 有向图的拓扑序列</h3><ul><li><p><strong>宽度优先搜索</strong>的应用</p></li><li><p>拓扑序列：所有的边都是从前指向后的</p><ul><li><strong>有向无环图</strong>一定存在拓扑序列——所以有向无环图称为拓扑图</li></ul></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-function><span class=hljs-type>bool</span> <span class=hljs-title>tosort</span><span class=hljs-params>()</span></span>&#123;<br>    <span class=hljs-type>int</span> hh = <span class=hljs-number>0</span>, tt = <span class=hljs-number>-1</span>;<br><br>    <span class=hljs-comment>// d[i] 存储点的入度</span><br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n; i ++ )&#123;<br>        <span class=hljs-keyword>if</span> (!d[i])<br>            q[++ tt] = i; <span class=hljs-comment>// 加入所有入度为 0 的点</span><br>    &#125;<br><br>    <span class=hljs-keyword>while</span> (hh &lt;= tt)&#123;<br>        <span class=hljs-type>int</span> t = q[hh ++];<br>        <span class=hljs-comment>// 对于队头 t，遍历其子节点，将子节点每个入度 - 1，如果入度为 0 则入队。</span><br>        <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = h[t]; i != <span class=hljs-number>-1</span>; i = ne[i])&#123;<br>            <span class=hljs-type>int</span> j = e[i];<br>            <span class=hljs-keyword>if</span> (--d[j] == <span class=hljs-number>0</span>)  <br>                q[++ tt] = j;<br>        &#125;<br>    &#125;<br><br>    <span class=hljs-comment>//如果所有点都入队了，说明存在拓扑序列；</span><br>    <span class=hljs-keyword>return</span> tt = n - <span class=hljs-number>1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id=最短路><a class=markdownIt-Anchor href=#最短路></a> 最短路</h2><div class="note note-info"><p>图论最难的部分是<strong>实现</strong></p></div><ul><li>图中有 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=application/x-tex>n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">n</span></span></span></span> 个点、<span class=katex><span class=katex-mathml><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=application/x-tex>m</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">m</span></span></span></span> 条边</li></ul><pre><code class=mermaid>graph LR
    A[最短路] --&gt;B[单源最短路]
    A --&gt; C[多源汇最短路]
    B --&gt; D[所有边权都是正数]
    B --&gt; E[存在负权边]
    D --&gt; F[朴素 Dijstra 算法]
    D --&gt; G[堆优化版的 Dijstra 算法]
    E --&gt; H[Bellman-Ford]
    E --&gt; I[SPFA]
    C --&gt; J[Floyd 算法]
</code></pre><h3 id=dijkstra-算法><a class=markdownIt-Anchor href=#dijkstra-算法></a> Dijkstra 算法</h3><h4 id=朴素-dijkstra-算法><a class=markdownIt-Anchor href=#朴素-dijkstra-算法></a> 朴素 Dijkstra 算法</h4><ul><li><p>时间复杂度 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>m</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(n^2 +m)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1.064108em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class=mord><span class="mord mathdefault">n</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141079999999999em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault">m</span><span class=mclose>)</span></span></span></span></p></li><li><p>思路</p><ol><li>dist[1] = 0, dist[i] = + INF;</li><li>for i in 1 ~ n:<br>t ← 不在 s 中的、距离最近的点（s 是当前已确定最短距离的点）;<br>s ← t;<br>用 t 更新其它点（1 ~ n）到<strong>起点</strong>的距离;</li><li>执行 2 操作 n 次</li></ol></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> g[N][N]; <span class=hljs-comment>// 存储每条边</span><br><span class=hljs-type>int</span> dist[N]; <span class=hljs-comment>// 存储 1 号点到每个点的距离</span><br><span class=hljs-type>bool</span> st[N]; <span class=hljs-comment>// 存储每个点的最短路是否已经确定</span><br><br><span class=hljs-comment>// 求 1 号点到 n 号点的最短路，若不存在则返回 -1</span><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>dijkstra</span><span class=hljs-params>()</span></span>&#123;<br>    <span class=hljs-built_in>memset</span>(dist, <span class=hljs-number>0x3f</span>, <span class=hljs-keyword>sizeof</span> dist);<br>    dist[<span class=hljs-number>1</span>] = <span class=hljs-number>0</span>;<br><br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>0</span>; i &lt;n - <span class=hljs-number>1</span>; i ++ )&#123;<br>        <span class=hljs-type>int</span> t = <span class=hljs-number>-1</span>;<br>        <span class=hljs-comment>// 在未确定最短路的点中，寻找距离最小的点 t</span><br>        <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> j = <span class=hljs-number>1</span>; j &lt;= n; j ++ )<br>            <span class=hljs-keyword>if</span> (!st[j] &amp;&amp;(t == <span class=hljs-number>-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>        <br>        st[t] = <span class=hljs-literal>true</span>;<br><br>        <span class=hljs-comment>// 用 t 更新其他点的距离</span><br>        <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> j = <span class=hljs-number>1</span>; j &lt;= n; j ++ )&#123;<br>            dist[j] = <span class=hljs-built_in>min</span>(dist[j], dist[t] + g[t][j]);<br>        &#125;<br>    &#125;<br><br>    <span class=hljs-keyword>if</span> (dist[n] == <span class=hljs-number>0x3f3f3f3f</span>) <span class=hljs-keyword>return</span> <span class=hljs-number>-1</span>;<br>    <span class=hljs-keyword>return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id=堆优化版-dijkstra><a class=markdownIt-Anchor href=#堆优化版-dijkstra></a> 堆优化版 Dijkstra</h4><ul><li><p>我们发现，朴素 Dijkstra 每次需要寻找未确定最短路的点中<strong>距离最小</strong>的点，那么我们可以用<strong>小根堆</strong>来维护这个最小值点</p></li><li><p>时间复杂度 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>m</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(mlogn)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">m</span><span class="mord mathdefault" style=margin-right:.01968em>l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style=margin-right:.03588em>g</span><span class="mord mathdefault">n</span><span class=mclose>)</span></span></span></span>，适合<strong>稀疏图</strong></p></li><li><p>使用<strong>邻接表</strong>存储，是为了<strong>快速找到从每个点出发的所有邻边</strong></p></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-keyword>typedef</span> pair&lt;<span class=hljs-type>int</span>, <span class=hljs-type>int</span>&gt; PII;<br><br><span class=hljs-type>int</span> n; <span class=hljs-comment>// 点的数量</span><br><span class=hljs-type>int</span> h[N], w[N], e[N], ne[N], idx; <span class=hljs-comment>// 邻接表存储</span><br><span class=hljs-type>int</span> dist[N]; <span class=hljs-comment>// 存储 1 号点到每个点的距离</span><br><span class=hljs-type>bool</span> st[N]; <span class=hljs-comment>// 存储每个点的最短路是否已经确定</span><br><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>dijkstra</span><span class=hljs-params>()</span></span>&#123;<br>    <span class=hljs-built_in>memset</span>(dist, <span class=hljs-number>0x3f</span>, <span class=hljs-keyword>sizeof</span> dist);<br>    dist[<span class=hljs-number>1</span>] = <span class=hljs-number>0</span>;<br>    priority_queue&lt;PII, vector&lt;PII&gt;, greater&lt;PII&gt;&gt; heap;<br>    heap.<span class=hljs-built_in>push</span>(&#123;<span class=hljs-number>0</span>, <span class=hljs-number>1</span>&#125;); <span class=hljs-comment>// first 存储距离，second 存储节点编号</span><br>    <br>    <span class=hljs-comment>//  队列为空时，即没有点更新距离</span><br>    <span class=hljs-keyword>while</span> (heap.<span class=hljs-built_in>size</span>())&#123;<br>        <span class=hljs-comment>// 相比于朴素版，这里直接取了堆顶</span><br>        <span class=hljs-keyword>auto</span> t = heap.<span class=hljs-built_in>top</span>();<br>        heap.<span class=hljs-built_in>pop</span>();<br><br>        <span class=hljs-type>int</span> ver = t.second, distance = t.first;<br><br>        <span class=hljs-keyword>if</span> (st[ver]) <span class=hljs-keyword>continue</span>;<br>        st[ver] = <span class=hljs-literal>true</span>;<br><br>        <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = h[ver]; i != <span class=hljs-number>-1</span>; i = ne[i])&#123;<br>            <span class=hljs-type>int</span> j = e[i];<br>            <span class=hljs-keyword>if</span> (dist[j] &gt; distance + w[i])&#123;<br>                dist[j] = distance + w[i];<br>                heap.<span class=hljs-built_in>push</span>(&#123;dist[j], j&#125;); <span class=hljs-comment>// 将更新了距离的点放入队列</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id=bellman-ford-算法><a class=markdownIt-Anchor href=#bellman-ford-算法></a> Bellman-Ford 算法</h3><ul><li><p>时间复杂度 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>n</mi><mi>m</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(nm)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class=mclose>)</span></span></span></span>，其中 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=application/x-tex>n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">n</span></span></span></span> 表示点数，<span class=katex><span class=katex-mathml><math><semantics><mrow><mi>m</mi></mrow><annotation encoding=application/x-tex>m</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">m</span></span></span></span> 表示边数</p></li><li><p>因为有<strong>负权边</strong>，因此<strong>每个点</strong>都需要对<strong>每个边</strong>进行遍历，从而更新 <code>dist[]</code></p></li><li><p>如果第 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>n</mi></mrow><annotation encoding=application/x-tex>n</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.43056em;vertical-align:0></span><span class="mord mathdefault">n</span></span></span></span> 次迭代仍然会<strong>松弛三角不等式</strong>，就说明存在一条长度是 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding=application/x-tex>n+1</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:.66666em;vertical-align:-.08333em></span><span class="mord mathdefault">n</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:.64444em;vertical-align:0></span><span class=mord>1</span></span></span></span> 的最短路径，由抽屉原理，路径中至少存在两个相同的点，说明图中存在<strong>负权回路</strong></p></li><li><p>注意最后的 <code>dist[n] &gt; 0x3f3f3f3f / 2</code></p></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> n, m;<br><span class=hljs-type>int</span> dist[N];<br><br><span class=hljs-keyword>struct</span> <span class="hljs-title class_">Edge</span>&#123; <br>    <span class=hljs-type>int</span> a, b, w;<br>&#125;edges[M]; <span class=hljs-comment>// 边，a表示出点，b表示入点，w表示边的权重</span><br><br><span class=hljs-comment>// 求 1 号点到 n 号点的最短路，若不存在则返回 -1</span><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>bellman_ford</span><span class=hljs-params>()</span></span>&#123;<br>    <span class=hljs-built_in>memset</span>(dist, <span class=hljs-number>0x3f</span>, <span class=hljs-keyword>sizeof</span> dist);<br>    dist[<span class=hljs-number>1</span>] = <span class=hljs-number>0</span>;<br><br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>0</span>; i &lt; n; i ++ )&#123;<br>        <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> j = <span class=hljs-number>0</span>; j &lt; m; j ++ )&#123;<br>            <span class=hljs-type>int</span> a = edges[j].a, b = edges[j].b, w = edges[j].w;<br>            dist[b] = <span class=hljs-built_in>min</span>(dist[b], dist[a] + w);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class=hljs-keyword>if</span> (dist[n] &gt; <span class=hljs-number>0x3f3f3f3f</span> / <span class=hljs-number>2</span>) <span class=hljs-keyword>return</span> <span class=hljs-number>-1</span>; <span class=hljs-comment>// 因为有负权边，所以即便是没有通路 dist[n] 也有可能减少了一些</span><br><span class=hljs-keyword>return</span> dist[n];<br><br></code></pre></td></tr></table></figure></li></ul><h3 id=spfa-算法><a class=markdownIt-Anchor href=#spfa-算法></a> spfa 算法</h3><ul><li><p><strong>队列优化</strong>的 Bellman-Ford 算法。仅更新<strong>队列中的点</strong>，这样就加快了速度。但是如果<strong>存在闭环</strong>，队列会不断更新从而不断循环。</p><ul><li>因此，判断负环的方法是引入 <code>cnt[]</code>，记录每个点最短距离更新的次数</li></ul></li><li><p>时间复杂度平均 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>m</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(m)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">m</span><span class=mclose>)</span></span></span></span>，最坏情况下 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>n</mi><mi>m</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(nm)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">m</span><span class=mclose>)</span></span></span></span>。因此时间不是很紧的题可以用 spfa 代替 Dijkstra。</p></li><li><p>为什么 spfa 最后说可以用 <code>dist[n]==0x3f3f3f3f</code> 进行判断？这是因为，Bellman-ford 在更新时，即便是没有通路从 1 到 n，但是与 n 相连的点 n - 1 也会让 <code>dist[n]</code> 更新；而 spfa 的话，如果没有连接有通路，那么 n - 1 是不会进入队列被更新到。因此 <code>dist[n]</code> 不会变化。</p></li><li><p>模板</p><ul><li>spfa 求 1 到 n 的最短路</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> n;  <span class=hljs-comment>// 总点数</span><br><span class=hljs-type>int</span> h[N], w[N], e[N], ne[N], idx;  <span class=hljs-comment>// 用邻接表存储所有边</span><br><span class=hljs-type>int</span> dist[N];  <span class=hljs-comment>// 存储 1 号点到每个点的距离</span><br><span class=hljs-type>bool</span> st[N];  <span class=hljs-comment>// 存储点是否在队列中</span><br><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>spfa</span><span class=hljs-params>()</span></span>&#123;<br>    <span class=hljs-built_in>memset</span>(dist, <span class=hljs-number>0x3f</span>, <span class=hljs-keyword>sizeof</span> dist);<br>    dist[<span class=hljs-number>1</span>] = <span class=hljs-number>0</span>;<br><br>    queue&lt;<span class=hljs-type>int</span>&gt; q;<br>    q.<span class=hljs-built_in>push</span>(<span class=hljs-number>1</span>);<br>    st[<span class=hljs-number>1</span>] = <span class=hljs-literal>true</span>;<br><br>    <span class=hljs-keyword>while</span> (q.<span class=hljs-built_in>size</span>())&#123;<br>        <span class=hljs-keyword>auto</span> t = q.<span class=hljs-built_in>front</span>();<br>        q.<span class=hljs-built_in>pop</span>();<br>        st[t] = <span class=hljs-literal>false</span>;<br><br>        <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = h[i]; i != <span class=hljs-number>-1</span>; i = ne[i])&#123;<br>            <span class=hljs-type>int</span> j = e[i];<br>            <span class=hljs-keyword>if</span> (dist[j] &gt; dist[t] + w[i])&#123;<br>                dist[j] = dist[t] + w[i];<br>                <span class=hljs-keyword>if</span> (!st[j])&#123;  <span class=hljs-comment>// 如果队列中已存在 j，则不需要将 j 重复插入</span><br>                    q.<span class=hljs-built_in>push</span>(j);<br>                    st[j] = <span class=hljs-literal>true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class=hljs-keyword>if</span> (dist[n] == <span class=hljs-number>0x3f3f3f3f</span>) <span class=hljs-keyword>return</span> <span class=hljs-number>-1</span>;<br>    <span class=hljs-keyword>return</span> dist[n];<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>判断图中是否存在负环</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> n;<br><span class=hljs-type>int</span> h[N], w[N], e[N], ne[N], idx;<br><span class=hljs-type>int</span> dist[N], cnt[N];<br><span class=hljs-type>bool</span> st[N];<br><br><span class=hljs-function><span class=hljs-type>bool</span> <span class=hljs-title>spfa</span><span class=hljs-params>()</span></span>&#123;<br>    queue&lt;<span class=hljs-type>int</span>&gt; q;<br><br>    <span class=hljs-comment>// 负环不一定要从点 1 出发，因此把所有点放入队列中</span><br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n; i ++ )&#123;<br>        q.<span class=hljs-built_in>push</span>(i);<br>        st[i] = <span class=hljs-literal>true</span>;<br>    &#125;<br><br>    <span class=hljs-keyword>while</span> (q.<span class=hljs-built_in>size</span>())&#123;<br>        <span class=hljs-keyword>auto</span> t = q.<span class=hljs-built_in>front</span>();<br>        q.<span class=hljs-built_in>pop</span>();<br><br>        st[t] = <span class=hljs-literal>false</span>;<br><br>        <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = h[t]; i != <span class=hljs-number>-1</span>; i = ne[i])&#123;<br>            <span class=hljs-type>int</span> j =e[i];<br>            <span class=hljs-keyword>if</span> (dist[j] &gt; dist[t] + w[i])&#123;<br>                dist[j] = dist[t] + w[i];<br>                cnt[j] = cnt[t] + <span class=hljs-number>1</span>;<br>                <span class=hljs-keyword>if</span> (cnt[j] &gt; n) <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>;  <span class=hljs-comment>// 说明最短路中至少含了 n + 1 个点</span><br>                <span class=hljs-keyword>if</span> (!st[j])&#123;<br>                    q.<span class=hljs-built_in>push</span>(j);<br>                    st[j] = <span class=hljs-literal>true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id=floyd-算法><a class=markdownIt-Anchor href=#floyd-算法></a> FLoyd 算法</h3><ul><li>时间复杂度是 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(n^3)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1.064108em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class=mord><span class="mord mathdefault">n</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141079999999999em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class=mclose>)</span></span></span></span></li><li>Floyd 算法极其简洁，但是难以理解，因为是用了 DP 思想：核心是公式 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>f</mi><mo stretchy=false>[</mo><mi>k</mi><mo stretchy=false>]</mo><mo stretchy=false>[</mo><mi>i</mi><mo stretchy=false>]</mo><mo stretchy=false>[</mo><mi>j</mi><mo stretchy=false>]</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy=false>(</mo><mi>f</mi><mo stretchy=false>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=false>]</mo><mo stretchy=false>[</mo><mi>i</mi><mo stretchy=false>]</mo><mo stretchy=false>[</mo><mi>j</mi><mo stretchy=false>]</mo><mo separator=true>,</mo><mi>f</mi><mo stretchy=false>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=false>]</mo><mo stretchy=false>[</mo><mi>i</mi><mo stretchy=false>]</mo><mo stretchy=false>[</mo><mi>k</mi><mo stretchy=false>]</mo><mo>+</mo><mi>f</mi><mo stretchy=false>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=false>]</mo><mo stretchy=false>[</mo><mi>k</mi><mo stretchy=false>]</mo><mo stretchy=false>[</mo><mi>j</mi><mo stretchy=false>]</mo><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>f[k][i][j]=min(f[k-1][i][j],f[k-1][i][k]+f[k-1][k][j])</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.10764em>f</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.03148em>k</span><span class=mclose>]</span><span class=mopen>[</span><span class="mord mathdefault">i</span><span class=mclose>]</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.05724em>j</span><span class=mclose>]</span><span class=mspace style=margin-right:.2777777777777778em></span><span class=mrel>=</span><span class=mspace style=margin-right:.2777777777777778em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class=mopen>(</span><span class="mord mathdefault" style=margin-right:.10764em>f</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.03148em>k</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mord>1</span><span class=mclose>]</span><span class=mopen>[</span><span class="mord mathdefault">i</span><span class=mclose>]</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.05724em>j</span><span class=mclose>]</span><span class=mpunct>,</span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault" style=margin-right:.10764em>f</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.03148em>k</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mord>1</span><span class=mclose>]</span><span class=mopen>[</span><span class="mord mathdefault">i</span><span class=mclose>]</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.03148em>k</span><span class=mclose>]</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.10764em>f</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.03148em>k</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mord>1</span><span class=mclose>]</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.03148em>k</span><span class=mclose>]</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.05724em>j</span><span class=mclose>]</span><span class=mclose>)</span></span></span></span>。在计算 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>f</mi><mo stretchy=false>[</mo><mi>k</mi><mo stretchy=false>]</mo></mrow><annotation encoding=application/x-tex>f[k]</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.10764em>f</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.03148em>k</span><span class=mclose>]</span></span></span></span> 时，需要依赖于 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>f</mi><mo stretchy=false>[</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy=false>]</mo></mrow><annotation encoding=application/x-tex>f[k-1]</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.10764em>f</span><span class=mopen>[</span><span class="mord mathdefault" style=margin-right:.03148em>k</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>−</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class=mord>1</span><span class=mclose>]</span></span></span></span>，所以 $k4 应该先被算出来。</li></ul><blockquote><p>一个笑话：为什么 Dijkstra 不能提出 floyd 算法？因为他的名字是 ijk 而不是 kij。</p></blockquote><ul><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-comment>// 初始化</span><br><span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n; i ++ )&#123;<br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> j = <span class=hljs-number>1</span>; j &lt;= n; j ++ )&#123;<br>        <span class=hljs-keyword>if</span> (i == j) d[i][j] = <span class=hljs-number>0</span>;<br>        <span class=hljs-keyword>else</span> d[i][j] = INF;<br>    &#125;<br>&#125;<br><br><span class=hljs-comment>// Floyd 算法结束后，d[a][b] 表示 a 到 b 的最短距离</span><br><span class=hljs-function><span class=hljs-type>void</span> <span class=hljs-title>floyd</span><span class=hljs-params>()</span></span>&#123;<br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> k = <span class=hljs-number>1</span>; k &lt;= n; k ++ )&#123;<br>        <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n; i ++ )&#123;<br>            <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> j = <span class=hljs-number>1</span>; j &lt;= n; j ++ )&#123;<br>                d[i][j] = <span class=hljs-built_in>min</span>(d[i][j], d[i][k] + d[k][j]);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id=最小生成树><a class=markdownIt-Anchor href=#最小生成树></a> 最小生成树</h2><pre><code class=mermaid>graph LR
    A[最小生成树] --&gt;B[Prim 算法]
    A --&gt; C[Kruskal 算法]
    B --&gt; D[朴素 Prim 算法]
    B --&gt; E[堆优化版的 Prim 算法]
</code></pre><h3 id=prim-算法><a class=markdownIt-Anchor href=#prim-算法></a> Prim 算法</h3><h4 id=朴素-prim-算法><a class=markdownIt-Anchor href=#朴素-prim-算法></a> 朴素 Prim 算法</h4><ul><li><p>适用于<strong>稠密图</strong></p></li><li><p>时间复杂度是 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><msup><mi>n</mi><mn>2</mn></msup><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(n^2)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1.064108em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class=mord><span class="mord mathdefault">n</span><span class=msupsub><span class=vlist-t><span class=vlist-r><span class=vlist style=height:.8141079999999999em><span style=top:-3.063em;margin-right:.05em><span class=pstrut style=height:2.7em></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class=mclose>)</span></span></span></span></p></li><li><p>思路</p><ol><li>dist[i] = + INF;</li><li>for i in 1 ~ n:<br>t ← 不在 s 中的、距离最近的点（s 是当前已确定最短距离的点）;<br>s ← t;<br>用 t 更新其它点（1 ~ n）到<strong>集合</strong>的距离;（点到集合的距离：点所有连到集合的边的最小距离）</li><li>执行 2 操作 n 次</li></ol></li><li><p>模板</p></li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> n;          <span class=hljs-comment>// n 表示点数</span><br><span class=hljs-type>int</span> g[N][N];        <br><span class=hljs-type>int</span> dist[N];    <span class=hljs-comment>// 存储其他点到当前最小生成树的距离</span><br><span class=hljs-type>bool</span> st[N];     <span class=hljs-comment>// 存储每个点是否已经在生成树中</span><br><br><span class=hljs-comment>// 如果图不连通，则返回 INF，否则返回最小生成树的树边权重之和</span><br><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>prim</span><span class=hljs-params>()</span></span>&#123;<br>    <span class=hljs-built_in>memset</span>(dist, <span class=hljs-number>0x3f</span>, <span class=hljs-keyword>sizeof</span> dist);<br><br>    <span class=hljs-type>int</span> res = <span class=hljs-number>0</span>;<br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>0</span>; i &lt; n; i ++ )&#123;<br>        <span class=hljs-type>int</span> t = <span class=hljs-number>-1</span>;<br>        <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> j = <span class=hljs-number>1</span>; j &lt;= n; j ++ )&#123;<br>            <span class=hljs-keyword>if</span> (!st[j] &amp;&amp; (t == <span class=hljs-number>-1</span> || dist[t] &gt; dist[j]))<br>                t = j;<br>        &#125;<br><br>        <span class=hljs-keyword>if</span> (i &amp;&amp; dist[t] == INF) <span class=hljs-keyword>return</span> INF;<br><br>        <span class=hljs-keyword>if</span> (i) res += dist[t];<br>        st[t] = <span class=hljs-literal>true</span>;<br><br>        <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> j = <span class=hljs-number>1</span>; j &lt;= n; j ++ ) dist[j] = <span class=hljs-built_in>min</span>(dist[j], g[t][j]);<br>    &#125;<br>    <span class=hljs-keyword>return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id=堆优化版的-prim-算法><a class=markdownIt-Anchor href=#堆优化版的-prim-算法></a> 堆优化版的 Prim 算法</h4><ul><li>适用于<strong>稀疏图</strong>【不常用，因为不好写】</li><li>时间复杂度是 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(m\log n)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">m</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault">n</span><span class=mclose>)</span></span></span></span></li></ul><h3 id=kruskal-算法><a class=markdownIt-Anchor href=#kruskal-算法></a> Kruskal 算法</h3><ul><li>适用于<strong>稀疏图</strong></li><li>时间复杂度是 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(m\log m)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">m</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault">m</span><span class=mclose>)</span></span></span></span></li><li>思路<ol><li>按所有边按权重从小到大排序（瓶颈 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>m</mi><mi>log</mi><mo>⁡</mo><mi>m</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(m\log m)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">m</span><span class=mspace style=margin-right:.16666666666666666em></span><span class=mop>lo<span style=margin-right:.01389em>g</span></span><span class=mspace style=margin-right:.16666666666666666em></span><span class="mord mathdefault">m</span><span class=mclose>)</span></span></span></span>）</li><li>枚举每条边 ab（权重为 c），如果 a、b 不连通，将这条边加入集合中</li></ol></li><li>模板</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br><span class=line>32</span><br><span class=line>33</span><br><span class=line>34</span><br><span class=line>35</span><br><span class=line>36</span><br><span class=line>37</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> n, m;<br><span class=hljs-type>int</span> p[N];<br><br><span class=hljs-keyword>struct</span> <span class="hljs-title class_">Edge</span>&#123;<br>    <span class=hljs-type>int</span> a, b, w;<br><br>    <span class=hljs-type>bool</span> <span class=hljs-keyword>operator</span>&lt; (<span class=hljs-type>const</span> Edge &amp;W)<span class=hljs-type>const</span>&#123;<br>        <span class=hljs-keyword>return</span> w &lt; W.w<br>    &#125;<br>&#125;edges[M];<br><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>find</span><span class=hljs-params>(<span class=hljs-type>int</span> x)</span></span>&#123;<br>    <span class=hljs-keyword>if</span> (p[x] != x) p[x] = <span class=hljs-built_in>find</span>(p[x]);<br>    <span class=hljs-keyword>return</span> p[x];<br>&#125;<br><br><span class=hljs-function><span class=hljs-type>int</span> <span class=hljs-title>kruskal</span><span class=hljs-params>()</span></span>&#123;<br>    <span class=hljs-built_in>sort</span>(edges, edges + m);<br><br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n; i ++ ) p[i] = i;<br><br><br>    <span class=hljs-type>int</span> res = <span class=hljs-number>0</span>, cnt = <span class=hljs-number>0</span>;<br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>0</span>; i &lt; m; i ++ )&#123;<br>        <span class=hljs-type>int</span> a = edges[i].a, b = edges[i].b, w = edges[i].w;<br><br>        a = <span class=hljs-built_in>find</span>(a), b = <span class=hljs-built_in>find</span>(b);<br>        <span class=hljs-keyword>if</span> (a != b)&#123;<br>            p[a] = b;<br>            res += w;<br>            cnt ++;<br>        &#125;<br>    &#125;<br>    <span class=hljs-keyword>if</span> (cnt &lt; n - <span class=hljs-number>1</span>) <span class=hljs-keyword>return</span> INF;  <span class=hljs-comment>// 最小生成树最后有 n - 1 条边</span><br>    <span class=hljs-keyword>return</span> res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id=二分图><a class=markdownIt-Anchor href=#二分图></a> 二分图</h2><h3 id=染色法><a class=markdownIt-Anchor href=#染色法></a> 染色法</h3><ul><li>时间复杂度 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>n</mi><mo>+</mo><mi>m</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(n+m)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">n</span><span class=mspace style=margin-right:.2222222222222222em></span><span class=mbin>+</span><span class=mspace style=margin-right:.2222222222222222em></span></span><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault">m</span><span class=mclose>)</span></span></span></span></li><li>用于<strong>判断</strong>一个图是不是二分图<ul><li>二分图：图中不含奇数环</li></ul></li><li>思路<br>for i in 1 ~ n:<br>if i 未染色：<br>dfs(i, 1)</li><li>模板</li></ul><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br><span class=line>26</span><br><span class=line>27</span><br><span class=line>28</span><br><span class=line>29</span><br><span class=line>30</span><br><span class=line>31</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> n;<br><span class=hljs-type>int</span> h[N], e[M], ne[M], idx;<br><span class=hljs-type>int</span> color[N];  <span class=hljs-comment>// 表示每个点的颜色，-1表示未染色，0表示白色，1表示黑色</span><br><br><br><span class=hljs-comment>// 参数：u表示当前节点，c表示当前点的颜色</span><br><span class=hljs-function><span class=hljs-type>bool</span> <span class=hljs-title>dfs</span><span class=hljs-params>(<span class=hljs-type>int</span> u, <span class=hljs-type>int</span> c)</span></span>&#123;<br>    color[u] = c;<br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = h[u]; i != <span class=hljs-number>-1</span>; i = ne[i])&#123;<br>        <span class=hljs-type>int</span> j = e[i];<br>        <span class=hljs-keyword>if</span> (color[j] == <span class=hljs-number>-1</span>)&#123;<br>            <span class=hljs-keyword>if</span> (!<span class=hljs-built_in>dfs</span>(j, !c)) <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;<br>        &#125;<span class=hljs-keyword>else</span> <span class=hljs-keyword>if</span> (color[j] == c) <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;<br>    &#125;<br>    <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>;<br>&#125;<br><br><br><span class=hljs-function><span class=hljs-type>bool</span> <span class=hljs-title>check</span><span class=hljs-params>()</span></span>&#123;<br>    <span class=hljs-built_in>memset</span>(color, <span class=hljs-number>-1</span> <span class=hljs-keyword>sizeof</span> color);<br>    <span class=hljs-type>bool</span> flag = <span class=hljs-literal>true</span>;<br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n; i ++ )&#123;<br>        <span class=hljs-keyword>if</span> (color[i] == <span class=hljs-number>-1</span>)&#123;<br>            <span class=hljs-keyword>if</span>(!<span class=hljs-built_in>dfs</span>(i, <span class=hljs-number>0</span>))&#123;<br>                flag = <span class=hljs-literal>false</span>;<br>                <span class=hljs-keyword>break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=hljs-keyword>return</span> flag;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id=匈牙利算法><a class=markdownIt-Anchor href=#匈牙利算法></a> 匈牙利算法</h3><ul><li><p>时间复杂度 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>m</mi><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(mn)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class=mclose>)</span></span></span></span>，实际运行时间远小于 <span class=katex><span class=katex-mathml><math><semantics><mrow><mi>O</mi><mo stretchy=false>(</mo><mi>m</mi><mi>n</mi><mo stretchy=false>)</mo></mrow><annotation encoding=application/x-tex>O(mn)</annotation></semantics></math></span><span class=katex-html aria-hidden=true><span class=base><span class=strut style=height:1em;vertical-align:-.25em></span><span class="mord mathdefault" style=margin-right:.02778em>O</span><span class=mopen>(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">n</span><span class=mclose>)</span></span></span></span></p></li><li><p>用于求二分图的<strong>最大匹配</strong></p></li><li><p>思路</p><ul><li>遍历第一个集合的点，找与其可以匹配的点。可以匹配的点满足这样的规则：<ol><li>如果这个点没有被匹配，那么它俩匹配</li><li>如果这个点被匹配过了，那么考虑与它之前匹配的点<strong>能否匹配其它的点</strong>。如果可以，那么这个点与新点匹配；否则不可以匹配。</li></ol></li></ul></li><li><p>模板</p><figure class="highlight c++"><table><tr><td class=gutter><pre><span class=line>1</span><br><span class=line>2</span><br><span class=line>3</span><br><span class=line>4</span><br><span class=line>5</span><br><span class=line>6</span><br><span class=line>7</span><br><span class=line>8</span><br><span class=line>9</span><br><span class=line>10</span><br><span class=line>11</span><br><span class=line>12</span><br><span class=line>13</span><br><span class=line>14</span><br><span class=line>15</span><br><span class=line>16</span><br><span class=line>17</span><br><span class=line>18</span><br><span class=line>19</span><br><span class=line>20</span><br><span class=line>21</span><br><span class=line>22</span><br><span class=line>23</span><br><span class=line>24</span><br><span class=line>25</span><br></pre></td><td class=code><pre><code class="hljs c++"><span class=hljs-type>int</span> n1, n2;   <span class=hljs-comment>// n1 表示集合 1 中的点数，n2 表示集合 2 中的点数</span><br><span class=hljs-type>int</span> h[N], e[M], ne[M], idx;  <span class=hljs-comment>// 匈牙利算法中只会用到从第一个集合指向第二个集合的边，所以这里只用存一个方向的边</span><br><span class=hljs-type>int</span> match[M]; <span class=hljs-comment>// 存储集合 2 中每个点当前匹配集合 1 中对应的点</span><br><span class=hljs-type>bool</span> st[N];   <span class=hljs-comment>// 表示集合 2 中的点是否被遍历过，为了避免 find(x) 做深搜无限循环</span><br><br><span class=hljs-function><span class=hljs-type>bool</span> <span class=hljs-title>find</span><span class=hljs-params>(<span class=hljs-type>int</span> x)</span></span>&#123;<br>    <span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = h[x]; i != <span class=hljs-number>-1</span>; i = ne[i])&#123;<br>        <span class=hljs-type>int</span> j = e[i];<br>        <span class=hljs-keyword>if</span> (!st[j])&#123;<br>            st[j] = <span class=hljs-literal>true</span>;<br>            <span class=hljs-keyword>if</span> (match[j] = <span class=hljs-number>0</span> || <span class=hljs-built_in>find</span>(<span class=hljs-built_in>match</span>([j])))&#123;<br>                match[j] = x;<br>                <span class=hljs-keyword>return</span> <span class=hljs-literal>true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class=hljs-keyword>return</span> <span class=hljs-literal>false</span>;<br>&#125;<br><br><span class=hljs-comment>// 求最大匹配数，依次枚举第一个集合中的每个点能否匹配第二个集合中的点</span><br><span class=hljs-type>int</span> res = <span class=hljs-number>0</span>;<br><span class=hljs-keyword>for</span> (<span class=hljs-type>int</span> i = <span class=hljs-number>1</span>; i &lt;= n1; i ++ )&#123;<br>    <span class=hljs-built_in>memset</span>(st, <span class=hljs-literal>false</span>, <span class=hljs-keyword>sizeof</span> st);  <span class=hljs-comment>// 每次都要刷新 st[]</span><br>    <span class=hljs-keyword>if</span> (<span class=hljs-built_in>find</span>(i)) res ++;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><p>算法备忘录系列目录：<br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/ >第一节 算法备忘录·基础算法</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ >第二节 算法备忘录·数据结构</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7STL/ >第三节 算法备忘录·杂项</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%90%9C%E7%B4%A2%E4%B8%8E%E5%9B%BE%E8%AE%BA/ >第四节 算法备忘录·搜索与图论</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%95%B0%E5%AD%A6%E7%9F%A5%E8%AF%86/ >第五节 算法备忘录·数学知识</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/ >第六节 算法备忘录·动态规划</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E8%B4%AA%E5%BF%83/ >第七节 算法备忘录·贪心</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%97%B6%E7%A9%BA%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/ >第八节 算法备忘录·时空复杂度分析</a><br><a href=https://justloseit.top/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7%E6%9D%82%E9%A1%B9/ >第九节 算法备忘录·杂项</a></p></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class=category-chains><span class=category-chain><a href=/categories/%E7%AC%94%E8%AE%B0/ class=category-chain-item>笔记</a></span></span></div><div class=post-meta><i class="iconfont icon-tags"></i> <a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/ class=print-no-link>#计算机</a> <a href=/tags/%E7%AE%97%E6%B3%95/ class=print-no-link>#算法</a></div></div><div class="license-box my-3"><div class=license-title><div>算法备忘录·搜索与图论</div><div>https://justloseit.top/算法备忘录·搜索与图论/</div></div><div class=license-meta><div class=license-meta-item><div>作者</div><div>Mobilis In Mobili</div></div><div class="license-meta-item license-meta-date"><div>发布于</div><div>2021年8月21日</div></div><div class="license-meta-item license-meta-date"><div>更新于</div><div>2024年5月15日</div></div><div class=license-meta-item><div>许可协议</div><div><a class=print-no-link target=_blank href=https://creativecommons.org/licenses/by/4.0/ ><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-cc-by"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href=/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%87%E5%BF%98/ title=操作系统备忘><i class="iconfont icon-arrowleft"></i> <span class=hidden-mobile>操作系统备忘</span> <span class=visible-mobile>上一篇</span></a></article><article class="post-next col-6"><a href=/%E7%AE%97%E6%B3%95%E5%A4%87%E5%BF%98%E5%BD%95%C2%B7STL/ title=算法备忘录·STL><span class=hidden-mobile>算法备忘录·STL</span> <span class=visible-mobile>下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article id=comments><div id=valine></div><script type=text/javascript>Fluid.utils.loadComments("#valine",function(){Fluid.utils.createScript("https://lib.baomitu.com/valine/1.5.1/Valine.min.js",function(){var i=Object.assign({appId:"t4w421aIGl2GXkT0tSGoap5I-gzGzoHsz",appKey:"BpNeeVt0v3tKAbF1L6RTf94X",path:"window.location.pathname",placeholder:"说点什么",avatar:"retro",meta:["nick","mail","link"],requiredFields:[],pageSize:10,lang:"zh-CN",highlight:!0,recordIP:!1,serverURLs:"https://t4w421ai.lc-cn-n1-shared.com",emojiCDN:null,emojiMaps:null,enableQQ:!1},{el:"#valine",path:window.location.pathname});new Valine(i),Fluid.utils.waitElementVisible("#valine .vcontent",()=>{var i="#valine .vcontent img:not(.vemoji)";Fluid.plugins.imageCaption(i),Fluid.plugins.fancyBox(i)})})})</script><noscript>Please enable JavaScript to view the comments</noscript></article></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class=sidebar style=margin-left:-1rem><div id=toc><p class=toc-header><i class="iconfont icon-list"></i> <span>目录</span></p><div class=toc-body id=toc-body></div></div></aside></div></div></div><script>Fluid.utils.createScript("https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js",function(){mermaid.initialize({theme:"default"}),Fluid.utils.listenDOMLoaded(function(){Fluid.events.registerRefreshCallback(function(){"mermaid"in window&&mermaid.init()})})})</script><a id=scroll-top-button aria-label=TOP href=# role=button><i class="iconfont icon-arrowup" aria-hidden=true></i></a><div class="modal fade" id=modalSearch tabindex=-1 role=dialog aria-labelledby=ModalLabel aria-hidden=true><div class="modal-dialog modal-dialog-scrollable modal-lg" role=document><div class=modal-content><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type=button id=local-search-close class=close data-dismiss=modal aria-label=Close><span aria-hidden=true>&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type=text id=local-search-input class="form-control validate"> <label data-error=x data-success=v for=local-search-input>关键词</label></div><div class=list-group id=local-search-result></div></div></div></div></div></main><footer><div class=footer-inner><div class=footer-content><a href=https://hexo.io target=_blank rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href=https://github.com/fluid-dev/hexo-theme-fluid target=_blank rel="nofollow noopener"><span>Fluid</span></a></div><div class=statistics><span id=leancloud-site-pv-container style=display:none>总访问量 <span id=leancloud-site-pv></span> 次 </span><span id=leancloud-site-uv-container style=display:none>总访客数 <span id=leancloud-site-uv></span> 人</span></div><div class=beian><span><a href=http://beian.miit.gov.cn/ target=_blank rel="nofollow noopener"><a target=_blank rel=noopener href=https://beian.miit.gov.cn>京ICP备2021006744号-1</a> </a></span><span><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=11010802034644" rel="nofollow noopener" class=beian-police target=_blank><span style=visibility:hidden;width:0>|</span> <img src=/img/police_beian.png alt=police-icon> <span>京公网安备 11010802034644号</span></a></span></div></div></footer><script src=https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js></script><link rel=stylesheet href=https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src=https://lib.baomitu.com/jquery/3.6.4/jquery.min.js></script><script src=https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js></script><script src=/js/events.js></script><script src=/js/plugins.js></script><script src=https://lib.baomitu.com/typed.js/2.0.12/typed.min.js></script><script>(t=>{var e=Fluid.plugins.typing;(t=t.getElementById("subtitle"))&&e&&e(t.getAttribute("data-typed-text"))})((window,document))</script><script src=/js/img-lazyload.js></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){var t;"tocbot"in window&&(tocbot.refresh(),0!==(t=jQuery("#toc")).length)&&tocbot&&0<t.find(".toc-list-item").length&&t.css("visibility","visible")}))})</script><script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript("https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js",function(){window.anchors.options={placement:CONFIG.anchorjs.placement,visible:CONFIG.anchorjs.visible},CONFIG.anchorjs.icon&&(window.anchors.options.icon=CONFIG.anchorjs.icon);var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(window.anchors.options.class="anchorjs-link-left"),window.anchors.add(o.join(", ")),Fluid.events.registerRefreshCallback(function(){if("anchors"in window){anchors.removeAll();var n,o=[];for(n of(CONFIG.anchorjs.element||"h1,h2,h3,h4,h5,h6").split(","))o.push(".markdown-body > "+n.trim());"left"===CONFIG.anchorjs.placement&&(anchors.options.class="anchorjs-link-left"),anchors.add(o.join(", "))}})})</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script defer=defer src=/js/leancloud.js></script><script src=/js/local-search.js></script><script src=/js/boot.js></script><noscript><div class=noscript-warning>博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript></body></html>